<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mae Blog]]></title>
  <link href="http://zhouhongmeiblog.github.io/atom.xml" rel="self"/>
  <link href="http://zhouhongmeiblog.github.io/"/>
  <updated>2014-12-02T22:33:17+08:00</updated>
  <id>http://zhouhongmeiblog.github.io/</id>
  <author>
    <name><![CDATA[maebook]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[呵呵]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/12/02/he-he/"/>
    <updated>2014-12-02T22:33:07+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/12/02/he-he</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2D]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/11/25/cocos2dsheng-ji/"/>
    <updated>2014-11-25T14:25:05+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/11/25/cocos2dsheng-ji</id>
    <content type="html"><![CDATA[<h3>概述</h3>

<p>cocos2d是一个基于MIT协议的开源框架，用于构建游戏、应用程序和其他图形界面交互应用。可以让你</p>

<p>在创建自己的多平台游戏时节省很多的时间。</p>

<p><code>注：MIT许可证之名源自麻省理工学院（Massachusetts Institute of Technology, MIT）
</code></p>

<!--more-->


<h3>开发环境</h3>

<p>OS X 10.9、Xcode5及以上</p>

<p>需要一个开发者账号，便于真机调试（渲染性能）</p>

<p> <strong>iOS apps </strong>: ios5及以上，iphone,iphone3GS,iPodTouch不支持</p>

<p><strong>OSX apps</strong>:OS X 10.9以上</p>

<h3>特点</h3>

<ol>
<li><p><strong>易于使用</strong>：游戏开发者可以把关注焦点放在游戏设置本身，而不必消耗大量时间学习晦涩难懂的OpenGL ES，此外，Cocos2D还提供了大量的规范。</p></li>
<li><p><strong>高效</strong>：Cocos2D基于OpenGL ES进行图形渲染，从而让移动设备的GPU性能发挥到极致。</p></li>
<li><p><strong>灵活</strong>：方便扩展，易于集成第三方库。</p></li>
<li><p><strong>免费</strong>：基于MIT协议的免费开源框架，用户可以放心使用，不用担心商业授权的问题。</p></li>
<li><p><strong>社区支持</strong>：关心Cocos2D的开发者自发建立了多个社区组织，可以方便的查阅各类技术资料。</p></li>
</ol>


<h3>家族成员</h3>

<h4>Cocos2d-x</h4>

<p>Cocos2d-x是一个用C++写跨平台开源游戏框架，它可以用来建立游戏，应用和其他基于跨平台的GUI交</p>

<p>互程序。</p>

<h4>Cocos2d-JS</h4>

<p>Cocos2d-JS 是Cocos2d-x引擎的javascript版本。用一系列简化javascript APIS来支持所有</p>

<p>Cocos2d-x功能。</p>

<h4>Cocos2d-XNA</h4>

<p>Cocos2d-XNA是一个用C#为XNA写的2D/3D游戏框架，它支持MonoGame运行机制。</p>

<h4>Cocos2d-Swift</h4>

<p>Cocos2d-Swift是用Xcode和objective &ndash; c建立一个跨平台2D游戏开源框架。</p>

<h4>Cocos2d(Python)</h4>

<p> Cocos2d(python)项目起源于“Cocos2d”。除了它是用Python编写的，和cocos2d-x一样。它是</p>

<p> 跨平台的:它作用于Windows、Linux和Mac。</p>

<h3>升级</h3>

<h4>V3</h4>

<ol>
<li><p>Android官方支持，通过Apportable，在iOS和Android 你的项目能够编译不用修改。</p></li>
<li><p>对API进行整理，他们已经对API中的每个方法进行检查，确保每个方法是一致、有效和最新的。</p></li>
<li><p>可以从Xcode中得到完整的API文档，我们为新手写了一个用户指南。</p></li>
<li><p>CCPhysics都是建立在Chipmunk上。</p></li>
<li><p>改进触摸处理事件。单指和多指触摸到每个节点上（UITouch 变成了 CCTouch）。</p>

<p> 触摸处理是在CCNode上，self.userInteractionEnabled = TRUE</p>

<p>CGPoint touchLocation = [touch locationInNode:self];</p>

<p>具体实现：<a href="https://www.makeschool.com/gamernews/366/touch-handling-in-cocos2d-30">touch-handling</a></p>

<pre><code> 注：

 Apportable：他们提供的SDk，可以让Object-C语言写的程序直接在Android平台上

 运行，也就是说，让你的iOS应用可以移植到Android设备上来。不过，现在，他们还只主要

 面向移动游戏应用。

 Chipmunk：chipmunk是一个开源2D物理引擎。具有速度快，用起来简单，更轻量级的物理

 引擎

 物理引擎：动态移动和静态的刚体

 它与Box2D的性能比较：

 编程语言上，Box2D是用C++写的，chipmunk用c写的

 chipmunk用像素作为物理单位，Box2D使用米作为物理单位，显示需要转换屏幕坐标

 Box2D有些功能chipmunk没有（针对快速移动物体），倾向轻量级或者容易上手用

 chipmunk

 chipmunk有一个很受欢迎oc接口，叫做spacemanger，能将精灵添加到刚体上，添加调试 

 用的绘图。
</code></pre></li>
<li><p>CCLayer不再存在，CCLayer曾经用于与用户交互的场景类。在3.x版本任何CCNode能够处理触摸</p></li>
</ol>


<p>输入。CCNode是新的CCLayer。场景中使用CCScene都是继承CCNode。</p>

<ol>
<li>CCMenu再见，你好CCLayout!过去是用CCMenu创建菜单，现在用CCLayout能布局任何CCNode,</li>
</ol>


<p>你只要使用CCLayout容器和增加CCButton.</p>

<ol>
<li><p>v2.每帧实现更新方法需要两步走，v3.你不需要实现scheduleUpdate方法。</p></li>
<li><p>用CMMotionManager取代了老UIAccelerometerDelegate.／cm是什么？</p></li>
</ol>


<h4>V3.1</h4>

<p>3.1版本有两大特性，物理引擎进行新的渲染和改进，新的渲染完全重写所有旧的OpenGL代码，它向后</p>

<p>兼容3.0API，除非你在游戏中自定义OpenGL代码，在这种情况下，你需要做些较小调整。</p>

<p>(1)新渲染器有很大的性能改进,也使得所有批处理自动绘图和可见性扑杀你。不再有任何需要批处理节</p>

<p>点(尽管他们仍在代码中保持向后兼容性）。</p>

<p>(2)在物理引擎方面,现在可以将物理与行动和动画。通过物理模拟动画节点将正确地传输能量节点,这使</p>

<p> 得它更加简单和直观的建立任何类型的游戏,使用物理。</p>

<p> 3.1使用新的GLKit.framework库用于做math运算</p>

<h4>V3.2</h4>

<p><a href="https://www.makegameswith.us/gamernews/402/cocos2d-32-with-cceffects-is-coming">CCEffects</a>:就像一个过滤器，你能应用到你游戏中任何精灵甚至更大区域通过使用CCEffectNode.</p>

<p>介绍CCEffects中的各种类可以从<a href="https://www.makegameswith.us/gamernews/402/cocos2d-32-with-cceffects-is-coming">CCEffects API</a>中了解.</p>

<h4>V3.3</h4>

<ol>
<li><p>充分利用强大苹果新的API，批处理渲染</p></li>
<li><p>Packages, allowing you to deliver server-based game content.</p>

<p>很大改进对android支持</p></li>
<li><p>Lots of new and advanced effects with the CCEffects API.</p></li>
</ol>


<p>//在AppDelegate
[CCBReader configureCCFileUtils]</p>

<h3>SpriteBuiler</h3>

<p>SpriteBuilder的前身是大名鼎鼎的cocosBuilder，是cocos2d下进行精灵，层，场景布局的简单</p>

<p>快速的可视化的开发工具。SpriteBuilder在继承了cocosBuilder后，提供了更多的新特性，比如改</p>

<p>良了资源的处理，更好地支持不同的分解，物理，语言等。</p>

<p>SpriteBuilder的主要目标是提供类似于Xcode故事板的cocos2d的游戏快速开发工具。</p>

<p>SpriteBuilder是一个可视化编辑器，允许您快速创建cocos2d的游戏。它可以让你通过拖放不同的组</p>

<p>件来创建用户界面（user interfaces），游戏场景(gameplay scenes)和级别（levels）的接口</p>

<p>文件和设置它们的位置。这样比在代码中定位每一个元素的屏幕位置要节省大量的时间。</p>

<p>SpriteBuilder的该核心功能工具包括管理你的Assets，创建动画，音频效果和粒子效果。</p>

<h4>工作流程</h4>

<p>当你要在你的游戏项目中使用SpriteBuilder，你要先创建一个新的SpriteBuilder项目，而不是一</p>

<p>个Xcode项目。当创建一个SpriteBuilder项目，SpriteBuilder将为你创建和维护一个嵌入式的</p>

<p>Xcode项目。在SpriteBuilder项目中，你能能管理你的游戏项目中所有的resources和assets。在</p>

<p>你的游戏中，您将为不同的场景（scenes）创建相应的接口文件（interface files）。接口文件</p>

<p>（interface files）将被.ccb文件（.ccb是SpriteBuilder的前身CocosBuilder命名而来的）</p>

<p>调用。SpriteBuilder还允许您创建代码连接，通过代码连接，您可以创建.ccb 文件和Objective-</p>

<p>C 类之间的联系。这意味着您可以在SpriteBuilder和在代码中为你的游戏对象添加行为-我们将在后</p>

<p>面深入讨论这个概念。</p>

<!--一般的，SpriteBuilder的工作流程看起来像这样：

在SpriteBuilder中创建一个新项目

将图像和其他资源添加到您的SpriteBuilder项目中

在你的游戏项目中为不同的场景（scenes）和物体（objects）创建多个.ccb文件

添加代码连接来扩展这些场景（scenes）和物体（objects）的行为

在SpriteBuilder中发布您的项目。这将更新你的Xcode项目链接的SpriteBuilder项目

从Xcode中运行你的游戏-->


<p>原理：</p>

<p>CCB Files &ndash; CCB Reader &ndash; CCScene/CCNode</p>

<h4>安装</h4>

<p>你可以免费从Mac App Store下载SpriteBuilder,有经验开发者可以构建SpriteBuilder资源。</p>

<h4>开始</h4>

<p>点击下载SpriteBuilder.app,第一次打开会出现一个空的SpriteBuilder窗口，它是一个不活跃的</p>

<p>项目因此所有的接口是不可用的。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder1.png" alt="image" /></p>

<h4>创建新项目</h4>

<p>在SpriteBuilder菜单中选择<code>File =&gt; New =&gt; Project...</code> 会出现对话框，为项目命名和选oc或者swift作为项目的主要语言。</p>

<p>点击<code>Save</code>当你给你第一个项目合适名字。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder2.png" alt="image" /></p>

<h4>使用</h4>

<p><a href="https://www.makegameswith.us/docs/#!/cocos2d/1.0/spritebuilder-ui">SpriteBuilder-UI</a>划分四个区域</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder6.png" alt="image" /></p>

<ol>
<li><p>资源/组件浏览器：在这里，您可以看到您所创建或添加到您的项目中的不同的资源和场景。您还可以选择不同类型的节点（Nodes）并将其拖动到场景中。</p></li>
<li><p>第一阶段：该阶段将预览您的当前场景。在这里，你可以安排属于一个场景的所有节点。</p></li>
<li><p>时间轴：时间轴用于在SpriteBuilder中创建动画。更多的时间轴细节我们将在以后详细讨论。</p></li>
<li><p>详情查看：一旦你选择场景中的节点，这个细节视图将显示大量关于该节点可编辑的信息。您可以修改位置，内容（例如一个标签的文本）和物理性质等。</p></li>
</ol>


<p><strong>文件视图</strong></p>

<p>在资源/组件的浏览器（标记为上图中第1节）第一个标签代表的文件视图。它会列出您已经添加的所</p>

<p>有.ccb文件和资源。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder7.png" alt="image" /></p>

<p>在这个视图中，您可以添加新的资源和调整项目中的文件夹层次结构。</p>

<p><strong>节点库</strong></p>

<p>第三个选项卡是节点库：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder8.png" alt="image" /></p>

<p>此面板显示了你可以用于构建游戏场景和菜单的所有可用的节点类型。</p>

<p><strong>检阅栏</strong></p>

<p>在详细信息视图（标记为上图中第4节）的第一个选项卡是检阅栏，一旦在你选中了一个场景中的对象的</p>

<p>时候，你可以使用这个面板来修改它的许多特性，如位置和颜色：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder9.png" alt="image" /></p>

<p><strong>代码连接</strong></p>

<p>在右侧面板中的第二个选项卡让您能够管理您选择的节点的代码连接。你可以在这里做的是为您的节点设</p>

<p>置自定义的Objective-C类（设置类名）：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder10.png" alt="image" /></p>

<h4>发布项目</h4>

<p>SpriteBuilder窗口几乎显示是一个空项目，为了发布这个工程，点击最左上角发布按钮。只要项目发</p>

<p>布，你就可以打开xcode.</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder3.png" alt="image" /></p>

<h4>使用SpriteBuilder管理资源</h4>

<p><strong>导入资源</strong></p>

<p>拖动解压的PeevedPenguinsAssets文件夹到资源窗格（MainScene.ccb下的空的空间）。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder11.png" alt="image" /></p>

<p><strong>调整自动缩放设置</strong></p>

<p>如果你看了资源文件夹中的图片资源，你会发现每个图像只提供一套资源而不是为视网膜和非视网膜设备</p>

<p>分别提供单独的资源。这是可能的，因为Spritebuilder支持自动缩放。</p>

<p>由于SpriteBuilder的自动缩放你只需要提供最高分辨率的图像， SpriteBuilder将自动生成低分</p>

<p>辨率的图像。如果你之前已经用了cocos2d，这意味着没有更多的定期和高清文件！</p>

<p>SpriteBuilder设置默认情况下，从4倍分辨率（视网膜图像的双精度）缩减资源。 Peeved</p>

<p>Penguins项目提供2倍高清资源（视网膜分辨率）, 所以我们必须改变我们的项目此设置。打开文件></p>

<p>项目设置和更改默认缩放2倍（phonehd）：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder12.png" alt="image" /></p>

<p>现在，当您通过SpriteBuilder发布，它会自动生成非视网膜iPhone资源。</p>

<p><strong>启用Smart Sprite Sheet</strong></p>

<p>SpriteBuilder还有一个很好的功能，你应该在你的游戏使用：Smart Sprite Sheets。当您使用</p>

<p>Smart Sprite Sheets，SpriteBuilder会为所有资源自动生成一个大的图像。这使得该设备中的</p>

<p>所有资源将被一次装入内存中，加快游戏的运行速度。</p>

<p>先将Peeved Penguins中的所有资源转换成Smart Sprite Sheets。你需要右键单击到该文件夹并</p>

<p>选择Make Smart Sprite Sheet：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder13.png" alt="image" /></p>

<p>在这之后你的文件夹的图标应该成为粉红色。现在，点击发布按钮。此时将产生你的Smart Sprite</p>

<p>Sheets。如果一切正常了，你会看到你的精灵表的一个很好的预览效果，你可以在资源窗格中选择它：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder14.png" alt="image" /></p>

<h4>打开Xocde项目</h4>

<p>你可以从菜单中选<code>File =&gt; Open Project in Xcode</code>，或者按<code>Shift+Cmd+O</code>，如果xocde项</p>

<p>目已经打开，它会把相关的xcode窗口带到最前面。</p>

<h4>构建和运行</h4>

<p>在Xcode中点击左上角的<code>Run</code>按钮去构建和运行项目。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder4.png" alt="image" /></p>

<p>恭喜你，你已经成功创建了你的第一个SpriteBuilder应用。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/11/25/SpriteBuilder5.png" alt="image" /></p>

<h3>Cocos2D</h3>

<pre><code>警告：如果你不想使用SpriteBuilder，你不得不写代码为每件事和手工管理资源。
</code></pre>

<h4>安装</h4>

<p>你可以从<a href="http://www.cocos2d-swift.org/download">cocos2d</a>官网下载一个最近版本的zip包或者<a href="https://www.makegameswith.us/docs/#!/docs/1.3/develop/cocos2d-build-from-sources">GitHub</a>。</p>

<ul>
<li> Scene management (workflow)</li>
<li> Transitions between scenes</li>
<li> Sprites and Sprite Sheets</li>
<li> Effects: Lens, Ripple, Waves, Liquid, etc.</li>
<li> Actions (behaviours):

<ul>
<li>Trasformation Actions: Move, Rotate, Scale, Fade, Tint, etc.</li>
<li>Composable actions: Sequence, Spawn, Repeat, Reverse</li>
<li>Ease Actions: Exp, Sin, Cubic, Elastic, etc.</li>
<li>Misc actions: CallFunc, OrbitCamera, Follow, Tween</li>
</ul>
</li>
<li> Basic menus and buttons</li>
<li> Integrated with [Chipmunk][6] physics engine</li>
<li> Particle system</li>
<li> Fonts:

<ul>
<li>Fast font rendering using Fixed and Variable width fonts</li>
<li>Support for .ttf fonts</li>
</ul>
</li>
<li> Tile Map support: Orthogonal, Isometric and Hexagonal</li>
<li> Parallax scrolling</li>
<li> Motion Streak</li>
<li> Render To Texture</li>
<li> Touch/Accelerometer on iOS</li>
<li> Touch/Mouse/Keyboard on Mac</li>
<li> Sound Engine support (CocosDenshion library) based on OpenAL</li>
<li> Integrated Slow motion/Fast forward</li>
<li> Fast textures: PVR compressed and uncompressed textures</li>
<li> Point based: RetinaDisplay mode compatible</li>
<li> Language: Objective-C</li>
<li> Open Source Commercial Friendly: Compatible with open and closed source projects</li>
<li> OpenGL ES 2.0 (iOS) / OpenGL 2.1 (Mac) based</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8界面布局和适配]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/10/16/ios8jie-mian-bu-ju-he-gua-pei/"/>
    <updated>2014-10-16T15:46:39+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/10/16/ios8jie-mian-bu-ju-he-gua-pei</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/10/16/ios8.png" alt="image" /></p>

<!--more-->


<h2>一 基本概念：</h2>

<p>我们知道，一款iOS应用，其主要UI组件是由一个个相对独立的可视单元构成，这些可视单元有的主要负责向用户输出有用的信息，有些则负责信息的输入（交互），交互的过程中往往还伴随有动画的效果，已达到整个信息传递的连贯性以及用户体验的细腻感。可视单元，在实际开发中主要是view、button等，那么这些可视单元的关系由两个基本的关系构成：兄弟关系和父子关系，整个视图单元就是一个树形结构：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/1.png" alt="image" />
对于任何一个UI组件，确定了它的（相对于父view）位置、大小也就确定了它在整个UI视图中的展示效果。
在iPad和iPhone 5出现之前，iOS设备就只有一种尺寸。我们在做屏幕适配时需要考虑的仅仅有设备方向而已。而很多应用并不支持转向，这样的话就完全没有屏幕适配的工作了。随着iPhone6、plus的发布，屏幕尺寸有了越来越多中可能，未来不排除更多尺寸的iPhone发布出来，这就要求我们的APP的UI元素具有在屏幕尺寸不同的设备上具有一定动态的可调性，已实现较好的UI展示效果。从目前苹果提供的技术来看，有下、中、上三种实现方法：
下策是，代码中判断当前设备的尺寸，对UI元素进行手工的调整，其缺点是显而易见的：代码复杂、容易出错、且维护难度大、灵活性极差；
 中策是，通过设置可视单元（UIView UIButton&hellip;）的autoresizing属性，预设当该view所在的环境（父view）发生变化时它的尺寸和位置应该如何调整，该方法可以在Xcode的interface builder中（storyboard 或者 xib）设置完成，但其只能针对父子关系进行有限的调整，比如左边距是否固定，尺寸是否可变等，而对于兄弟关系的调整则无法实现，对于UI比较固定的APP这种调节方式也算基本满足需求；
上策就是结合使用autolayout和sizeclass对UI可视单元的父子关系、兄弟关系进行全方位的调整，而且调节精度更高：不仅能确定一个view的位置尺寸的变化依据是什么，还能对这些依据加以不同的优先级，先满足什么条件，再满足什么条件，对于重要的位置尺寸可以优先保证，这样整个APP就具有极强的动态可调性，满足不同设备、不同应用场景下的需求。</p>

<h2>二 关于自动布局（Autolayout）</h2>

<p>在iOS7之前，为一个应用，特别是universal的应用制作UI时，我们总会首先想我们的目标设备的长宽各是多少，方向变换以后布局又应该怎么改变，然后进行布局。iOS6引入了AutoLayout来帮助开发者使用约束进行布局，这使得在某些情况下我们不再需要考虑尺寸，而可以专注于使用约束来规定位置。
Autolayout的作用非常明确：帮我们确定在不同设备、不同（父view）环境下，同一个可视单元所应具有合适的位置和尺寸，因此，当一个UIView上所施加的约束能够唯一确定它的frame（x, y, width, height）的时候我们的自动布局的使用才是正确的。而新手通常犯的两类错误就是约束不足（约束太少）和约束冲突两种（约束太多）。如果你给出的约束只能够确定这个view的大小，或者位置或者位置中的某一个项（比如x）的时候，就会出现约束不足的情况，在xib或者storyboard中，会以黄色的警告出现在左侧提示框内；如果你给出的约束推导出了两个甚至多个互相矛盾的位置尺寸结果的时候，就产生了布局错误，在编译的时候直接就build不过。
既然我们有了AutoLayout，那么其实通过约束来指定视图的位置和尺寸是没有什么问题的了，从这个方面来说，屏幕的具体的尺寸和方向已经不那么重要了。但是实战中这还不够，AutoLayout正如其名，只是一个根据约束来进行布局的方案，而在对应不同设备的具体情况下的体验上还有欠缺。一个最明显的问题是它不能根据设备类型来确定不同的交互体验。很多时候你还是需要判断设备到底是iPhone还是iPad，以及现在的设备方向究竟是竖直还是水平来做出判断。这样的话我们还是难以彻底摆脱对于设备的判断和依赖，而之后如果有新的尺寸和设备出现的话，这种依赖关系显然显得十分脆弱的（想想要是有iWatch的话..）。</p>

<p>所以在iOS8里，Apple从最初的设计哲学上将原来的方式推翻了，并引入了一整套新的理念，来适应设备不断的发展。这就是SizeClasses。</p>

<h2>三 关于iOS8新增的sizeclass属性</h2>

<p>对于任何设备来说，界面的宽度和高度都只分为两种描述：正常和紧凑。这样开发者便可以无视设备具体的尺寸，而是对这两类和它们的组合进行适配。这样不论在设计时还是代码上，我们都可以不再受限于具体的尺寸，而是变成遵循尺寸的视觉感官来进行适配。在Xcode中的具体体现如下图：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/2.png" alt="image" />
但是我们看到图中的宽度和高度都是Any,Any是什么意思呢？如果weight设为Any，height设置为Regular，那么在该状态下的界面元素在只要height为Regular，无论weight是Regular还是Compact的状态中都会存在。这种关系应该叫做继承关系，具体的四种界面描述与可继承的界面描述如下：</p>

<ul>
<li><p> w:Compact h:Compact 继承 (w:Any h:Compact , w:Compact h:Any , w:Any h:Any)</p></li>
<li><p> w:Regular h:Compact 继承 (w:Any h:Compact , w:Regular h:Any , w:Any h:Any)</p></li>
<li><p> w:Compact h:Regular 继承 (w:Any h:Regular , w:Compact h:Any , w:Any h:Any)</p></li>
<li><p> w:Regular h:Regular 继承 (w:Any h:Regular , w:Regular h:Any , w:Any h:Any)</p></li>
</ul>


<p>我们知道了iOS 8下面设备界面可以描述为4种，但是这么多设备(iPhone4S,iPhone5/5s,iPhone6,iPhone6 Plus,iPad,Apple Watch)具体对应什么描述呢？经过查看官方文档和具体实践得知具体对应关系如下:</p>

<ul>
<li><p> iPhone4S,iPhone5/5s,iPhone6</p>

<ul>
<li>竖屏：(w:Compact h:Regular)</li>
</ul>
</li>
<li><p> 横屏：(w:Compact h:Compact)</p></li>
<li><p> iPhone6 Plus</p>

<ul>
<li>竖屏：(w:Compact h:Regular)</li>
</ul>
</li>
<li><p> 横屏：(w:Regular h:Compact)</p></li>
<li><p> iPad</p>

<ul>
<li>竖屏：(w:Regular h:Regular)</li>
</ul>
</li>
<li><p> 横屏：(w:Regular h:Regular)</p></li>
<li><p> Apple Watch(猜测)</p>

<ul>
<li>竖屏：(w:Compact h:Compact)</li>
</ul>
</li>
<li><p> 横屏：(w:Compact h:Compact)</p></li>
</ul>


<h2>四 Size Classes手写代码</h2>

<p>为了表征Size Classes，Apple在iOS8中引入了一个新的类，UITraitCollection。这个类封装了像水平和竖直方向的Size Class等信息。iOS8的UIKit中大多数UI的基础类(包括UIScreen,UIWindow,UIViewController和UIView)都实现了UITraitEnvironment这个接口，通过其中的traitCollection这个属性，我们可以拿到对应的UITraitCollection对象，从而得知当前的Size Class，并进一步确定界面的布局。和UIKit中的响应者链正好相反，traitCollection将会在view hierarchy中自上而下地进行传递。对于没有指定traitCollection的UI部件，将使用其父节点的traitCollection。这在布局包含childViewController的界面的时候会相当有用。在UITraitEnvironment这个接口中另一个非常有用的是-traitCollectionDidChange:。在traitCollection发生变化时，这个方法将被调用。在实际操作时，我们往往会在ViewController中重写-traitCollectionDidChange:或者-willTransitionToTraitCollection:withTransitionCoordinator:方法(对于ViewController来说的话，后者也许是更好的选择，因为提供了转场上下文方便进行动画；但是对于普通的View来说就只有前面一个方法了)，然后在其中对当前的traitCollection进行判断，并进行重新布局以及动画。代码看起来大概会是这个样子：</p>

<ul>
<li>(void)willTransitionToTraitCollection:(UITraitCollection *)newCollection
            withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator
{
  [super willTransitionToTraitCollection:newCollection
              withTransitionCoordinator:coordinator];
  [coordinator animateAlongsideTransition:^(id <UIViewControllerTransitionCoordinatorContext> context)
  {
      if (newCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) {
          //To Do: modify something for compact vertical size
      } else {
          //To Do: modify something for other vertical size
      }
      [self.view setNeedsLayout];
  } completion:nil];
}</li>
</ul>


<p>在两个To Do处，我们要手写代码针对不同的状态做调整。</p>

<h2>五 Size Classes与Interface Builder</h2>

<p>Xcode6中Interface Builder对Size Class有了很强大的支持，xib中可以开启Size Classes如下图：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/3.png" alt="image" /></p>

<p>在不同的Size Classes描述下，界面元素可以选择安装还是不安装，具体操作如图：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/4.png" alt="image" /></p>

<p>在现在的 IB 界面的正下方，你可以看到一个 wAny hAny 的按钮，这代表现在的 IB 是对应任意高度和任意宽度的。点击后便可以选择需要为哪种 Size Class 进行编辑。默认情况在 Any Any 下的修改会对任意设备和任意方向生效，而如果先进行选择后再进行编辑，就表示编辑只对选中的设定生效。这样我们就很容易在同一个 storyboard 文件里对不同的设备进行适配：按照设备需要添加或者编辑某些约束，或者是在特定尺寸下隐藏某些 view (使用 Attribute Inspector 里的 Installed 选框的加号添加)。这使得使用 IB 制作通用程序变简单了，我们不再需要为 iPhone 和 iPad 准备两套 storyboard 了。</p>

<h2>六 storyboard中autolayout和size class的无敌配合</h2>

<p>对Xcode的interface builder比较熟悉的童鞋应该对UIButton的超强定制性映像深刻：通过选择button的不同状态（normal、height、disabled&hellip;），我们可以单独设置每一种状态，button的background image、image、text color等属性，见下图：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/5.png" alt="image" /></p>

<p>而Xcode6中对自动布局的重大变更有异曲同工之妙：开发者可以根据实际需要，针对size class的九种组合中的某一种或几种分别进行自动布局的设置，这样，当APP运行于不同屏幕、不同旋转方向的时候，就可以根据当前环境的size class情况使用我们预先设置好的布局信息，从而达到APP UI的极大灵活性。</p>

<p>和设置UIButton的不同状态的不同属性类似，我们首先选择一种size class，然后针对该种size class进行自动布局。下面我们以一个简单的布局场景为例进行说明：</p>

<p>假设，我们想实现下面这个效果：横屏和竖屏头像和label都能正常的现实，且在“比较恰当”的位置：显然横屏的时候，高度处于压缩的状态，（height: compact），我们需要先对正常的布局之外，还要添加一种（wAny, hCompact）size class的布局：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/10/16/6.png" alt="image" /></p>

<p>首先，我们对默认的sizeclass进行布局，确定头像和label的位置和尺寸：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/10/16/7.png" alt="image" /></p>

<p>设置完（wAny hAny）之后，点击wAny hAny文字（上图底部），选择（wAny hCompact）：注意点击后弹出一个九宫格浮框，拖动鼠标即可选择响应的size class，注意在右下角（红色方框表示），还可以选择是否install，如果取消勾选，则这个头像在当前size class下就不会被加载（自然也就不显示出来）。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/10/16/8.png" alt="image" /></p>

<p>在新的size class下我们开始添加新的布局，注意，这里并没有覆盖上一种size class我们定义好了得布局，知识针对当前的size class添加新的、独立的布局信息，狡兔三窟，Xcode6这下子一口气给了我们九个窟窿，爽！
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/9.png" alt="image" /></p>

<p>布局完毕，运行起来，即可达到我们想要的效果！</p>

<h2>七 Size Classes与Image Asset</h2>

<p>Xcode6中Image Asset也支持了Size Class,也就是说,我们可以对不同的Size Class指定不同的图片了。在Image Asset的编辑面板中选择某张图片，Inspector里现在多了一个Width和Height的组合，添加我们需要对应的Size Class，然后把合适的图拖上去，这样在运行时SDK就将从中挑选对应的Size的图进行替换了。支持Size Class的Image Asset编辑效果如下：
<img src="http://zhouhongmeiblog.github.io/images/2014/10/16/10.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS引导效果]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/09/18/iosyin-dao-xiao-guo/"/>
    <updated>2014-09-18T09:38:56+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/09/18/iosyin-dao-xiao-guo</id>
    <content type="html"><![CDATA[<p>Onboard只用几行代码让开发者以快速、简捷方式去创造漂亮、吸引人、实用的引导效果。</p>

<!--more-->


<h2>用法</h2>

<h3>Cocoapods</h3>

<h2>指南</h2>

<p>拖入<code>OnboardingViewController</code>和<code>OnboardingContentViewController</code>头文件和实现文件到项目中，在你的<code>AppDelegate</code>中导入，你将会给用户创造一个极好的引导效果。</p>

<h3>Objective-C</h3>

<pre><code>OnboardingContentViewController *firstPage = [[OnboardingContentViewController alloc] initWithTitle:@"Page Title" body:@"Page body goes here." image:[UIImage imageNamed:@"icon"] buttonText:@"Text For Button" action:^{
// do something here when users press the button, like ask for location services permissions, register for push notifications, connect to social media, or finish the onboarding process
}];
</code></pre>

<h3>Swift</h3>

<pre><code>let firstPage: OnboardingContentViewController = OnboardingContentViewController(title: "Page Title", body: "Page Body.", image: UIImage(named: "icon"), buttonText: "Button Text") {
// do something here when the user presses the button
}
</code></pre>

<p>然后创建</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/onboard_demo.gif" alt="image" /></p>

<h2>自定制</h2>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/key.png" alt="image" /></p>

<h2>模糊和遮罩</h2>

<h2>样例</h2>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/space1.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/space2.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/space3.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/space4.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/purple1.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/purple2.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/purple3.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/purple4.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/yellow1.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/yellow2.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/yellow3.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/yellow4.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/city1.png" alt="image" />
<img src="http://zhouhongmeiblog.github.io/images/2014/09/18/city2.png" alt="image" /></p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/09/18/city3.png" alt="image" /></p>

<h2>注意</h2>

<p>由于目前不支持水平方向引导，所以我建议使用的它应用是仅仅支持竖直方向或者封装它的是一个支持竖直方向<code>UINavigationContoller</code>的子类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS学习笔记－开源框架和类]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/08/26/iosxue-xi-bi-ji-%5Bnil%5Dkai-yuan-kuang-jia-he-lei/"/>
    <updated>2014-08-26T17:57:35+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/08/26/iosxue-xi-bi-ji-[nil]kai-yuan-kuang-jia-he-lei</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li><p>SDWebImage,UIImageView+WebCache加载一张图片。</p></li>
<li><p>UIViewExt用于定位坐标系统很有用。可以直接拿到bottom，top，left，right</p></li>
<li>CustomCatagory,是个类目，里面有navigationBar和UINavigationController的两种系统版本下自定义navigationBar背景图片方法，用于自定义navigationBar背景图片。</li>
<li>UIUtils工具类，里面我写了四个方法，一个获取documents下路径，一个将NSDate类型转换为字符串类型，一个将字符串转换为NSDate类型，还有一个将传进来的一个评分字符串分割开成两个，放在数组中，用于显示两个不同字体类型的评分。</li>
<li>CONSTS常量类，里面存放的是整个项目中需要使用的常量，写成宏形式。</li>
<li>UIFactory里面自定义了button类型，两种常用的button样式。</li>
<li>JSONKit类用于json数据解析</li>
<li>ASIHTTPRequest开源库，用于请求网络，需要依赖这五个系统自带库CFNetWork,SystemConfiguration,MobileCoreServices,和libz，libxml2.</li>
<li>DataSevrice网络请求类，分GET和POST请求两种方式，使用HTTP请求网络，使用ASIFormDataRequst类，需要一个url参数，当使用GET请求使用，不需要字典参数，增加一个请求头，当使用POST请求的时候需要一个字典参数，通过键key发送值。</li>
<li>转化成model对象类，将请求下来的网络数据字典转换为model对象，方便在其他类之间进行数据传输。</li>
<li>自定了一个单例类，将项目中需要在控制器之间传输的数据存取起来，方便调用。</li>
<li>使用OpenFlow开源框架，用于显示首页的图片要实现效果，在AFItemView类里面设置高清和低清两种样式，实现里面三个代理方法，一个用于图片切换时改变，一个用于请求加载图片。通过_operationQueue创建一个线程进行图片加载，可能造成线程堵塞。</li>
<li>EGORefreshTableHeaderView用于上拉下拉刷新，实现里面的几个代理方法，当手指放开时候会去跳用加载数据代理方法。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zip压缩和解压缩]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/23/zipya-suo-he-jie-ya-suo/"/>
    <updated>2014-07-23T13:59:37+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/23/zipya-suo-he-jie-ya-suo</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/23/zip.png" alt="image" /></p>

<!--more-->


<p>这篇文章我将演示如何在你的ios应用程序内部压缩和解压缩文件。我们将使用第三方库称为ZipArchive做到这点。虽然有几个解决方案压缩和解压缩文件，我觉得ZipArchive库是最快、最容易方式运行。</p>

<h2>为什么我要解压缩文件</h2>

<p>这是个好问题。有许多原因为什么在你的应用想要支持压缩和解压缩。这里有些原因：</p>

<h3>苹果App Store的50M下载限制</h3>

<p>苹果公司出于流量的考虑，规定在非WIFI环境下，限制用户只能下载小于50M的应用或游戏。这样一来，对于一些数据或数据包较大的应用，我们只能尽量减小 应用二进制包的体积。而把数据打包到zip中，这样App可以通过网络下载数据包，解压出所需要的内容，而且这样也可以动态的更新内容。</p>

<h3>动态更新内容</h3>

<p>这一点在上面已经提过了。如果应用所需要的资源需要动态更新，一种常见的做法是更新资源，重新打包，重新提交到App store，这样做你需要等待漫长的审核、上架时间。一般情况下是一周左右的时间。更好的方法是将这些资源打包放置在服务器上，App从服务器（或者云存储上下载，然后解压。这样做的好处显而易见，那就是可以快速更新，动态更新，不需要重新打包、上传、审核，省时省力。</p>

<h3>从web上下载zip文件</h3>

<p>Safari和邮件程序都不支持zip的查看，通过ZipArchive你就可以为你的设备增加查看zip文件的能力了，尽管App Store里已经有一些App支持这些功能了。</p>

<h3>建立工程</h3>

<p>首先从google code上check out一份代码，svn地址是：<a href="http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only">http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only</a></p>

<p>在终端中输入如下命令即可check out了：</p>

<p>svn co <a href="http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only">http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only</a>
或者直接从<a href="http://ziparchive.googlecode.com/files/ZipArchive.zip%E4%B8%8B%E8%BD%BD%E3%80%82">http://ziparchive.googlecode.com/files/ZipArchive.zip%E4%B8%8B%E8%BD%BD%E3%80%82</a></p>

<p>把minizip文件夹和ZipArchive.h以及ZipArchive.mm文件添加到你的工程中。</p>

<p>因为ZipArchive不支持ARC，所以如果你的工程开启了ARC，那么就需要对ZipArchive设置一下。在ZipArchive.mm编译选项中，增加-fno-objc-arc即可。</p>

<p>最后，需要为工程链接libz动态链接库。</p>

<p>至此，ZipArchive已经集成到你的工程中了，编译工程，应该可以编译成功。可能会有一些警告，这无关紧要，不影响编译。但是作为一个态度严谨的程序员，我强烈建议你看一下这些警告是怎么出现的，解决它们。请记住：在你的工程中，警告应该和错误一样被严肃处理</p>

<h3>下载和解压缩文件</h3>

<p>接下来就向大家展示在你的工程中如何从网上下载zip文件，解压缩，并读取zip压缩包中的文件内容。处于演示考虑，主要的目的是向大家演示
ZipArchive接口的使用方法，所以代码的错误处理和条件检查并没有做过多的考量，在实际的工程中，还是需要大家自己做更为严格的条件检查和错误处 理工作。</p>

<p>工程中只是在ViewController中增加了一个UIImageView和一个UILabel。我们将从网络上下载zip文件，zip文件中包含一张 图片和一个文本文件。下载解压后，图像会被渲染到UIImageView中，而文本会作为UILabel的内容展示。示例代码在文章末尾。希望读者朋友们 自行下载，编译，查看效果。</p>

<p>好，接下来讲一讲具体的实现：</p>

<h4>引入ZipArchive的头文件</h4>

<p> import &ldquo;ZipArchive.h&rdquo;</p>

<h4>下载zip文件</h4>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(
    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_async(queue, ^{
        NSURL *url = [NSURL URLWithString:@"http://www.icodeblog.com/wp-content/uploads/2012/08/zipfile.zip"];
        NSError *error = nil;
    // 2
        NSData *data = [NSData dataWithContentsOfURL:url options:0 error:&amp;error];

        if(!error)
        {        
        // 3
            NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
             NSString *path = [paths objectAtIndex:0];
             NSString *zipPath = [path stringByAppendingPathComponent:@"zipfile.zip"];

            [data writeToFile:zipPath options:0 error:&amp;error];

            if(!error)
            {
            // TODO: Unzip
            }
            else
            {
            NSLog(@"Error saving file %@",error);
            }
        }
        else
        {
        NSLog(@"Error downloading zip file: %@", error);
    }

});
</code></pre>

<p>  说明：上面这段代码的主要作用就是从iCodeBlog上下载一个zip文件，并写入到应用的缓存目录中。</p>

<p>现在zip文件已经下载下来了，接下来就是要解压缩，并将解压缩出来的文件利用起来。</p>

<h4>解压缩已下载的zip文件</h4>

<p>在第二步中，我们已经把zip文件下载到/Library/Caches/zipfile.zip，现在来解压缩。</p>

<p>把上面代码中的//TODO: Unzip用下面的代码替换掉。</p>

<pre><code>ZipArchive *za = [[ZipArchive alloc] init];
// 1
if ([za UnzipOpenFile: zipPath]) {      
// 2      
BOOL ret = [za UnzipFileTo: path overWrite: YES];
if (NO == ret){} [za UnzipCloseFile];

// 3
NSString *imageFilePath = [path stringByAppendingPathComponent:@"photo.png"];
NSString *textFilePath = [path stringByAppendingPathComponent:@"text.txt"];
NSData *imageData = [NSData dataWithContentsOfFile:imageFilePath options:0 error:nil];
UIImage *img = [UIImage imageWithData:imageData];
NSString *textString = [NSString stringWithContentsOfFile:textFilePath 
    encoding:NSASCIIStringEncoding error:nil];

// 4           
dispatch_async(dispatch_get_main_queue(), ^{
    self.imageView.image = img;
    self.label.text = textString;
});
</code></pre>

<p>  说明：</p>

<ul>
<li>在内存中解压缩文件</li>
<li>将解压缩的内容写到缓存目录中</li>
<li>使用解压缩后的文件</li>
<li>更新UI</li>
</ul>


<h3>压缩文件</h3>

<p>接下来看一下怎么进行文件压缩。在上面的步骤中，我们已经把一个zip文件解压缩到缓存目录中。现在我们再把解压缩出来的文件重新压缩为一个zip文件，并把这个zip文件写入到Documents目录里去（OMG，这两个文件太惨了，被反复蹂躏）</p>

<p>在示例工程代码中，我已经增加了一个按钮，并和一个IBAction相关联，按钮的处理函数名为zipFilesBUttonPressed:，具体代码如下：</p>

<pre><code>- (IBAction)zipFilesButtonPressed:(id)sender
{
    // 1
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docspath = [paths objectAtIndex:0];

   // 2
     paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
    NSString *cachePath = [paths objectAtIndex:0];

  // 3
    NSString *zipFile = [docspath stringByAppendingPathComponent:@"newzipfile.zip"];       

 // 4
    ZipArchive *za = [[ZipArchive alloc] init];
    [za CreateZipFile2:zipFile];

// 5
     NSString *imagePath = [cachePath stringByAppendingPathComponent:@"photo.png"];
     NSString *textPath = [cachePath stringByAppendingPathComponent:@"text.txt"];

// 6
    [za addFileToZip:imagePath newname:@"NewPhotoName.png"];
    [za addFileToZip:textPath newname:@"NewTextName.txt"];

// 7
    BOOL success = [za CloseZipFile2];    
    NSLog(@"Zipped file with result %d",success);
}
</code></pre>

<p>   说明：</p>

<ul>
<li><p>获取Documents目录，新的zip文件要写入到这个目录里。</p></li>
<li><p>获取Caches目录，要进行压缩的文件在这个目录里。</p></li>
<li><p>获取zip文件的全路径名。</p></li>
<li><p>创建一个ZipArchive实例，并创建一个内存中的zip文件。需要注意的是，只有当你调用了CloseZipFile2方法之后，zip文件才会从内存中写入到磁盘中去。</p></li>
<li><p>获取要被压缩的文件的全路径</p></li>
<li><p>把要压缩的文件加入到zip对象中去，加入的文件数量没有限制，也可以加入文件夹到zip对象中去。</p></li>
<li><p>把zip从内存中写入到磁盘中去。</p></li>
</ul>


<p>当点击按钮之后，在应用的Documents文件夹下应该有一个叫newzipfile.zip的文件。解压这个文件，就能解压出那两个被反复蹂躏的文件来</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 测试解决方案]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/03/distribute-app/"/>
    <updated>2014-07-03T14:10:19+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/03/distribute-app</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/iOS_Test.png" alt="image" /></p>

<!--more-->


<h3>App内测（Ad-Hoc）</h3>

<p>利用企业级开发证书和提供简单网页服务器搭建文件以及相关技术文档，把文件上传到您的网站，就可以是越狱和非越狱用户在iphone或者ipad上在线直接安装APP软件!</p>

<h4>发布流程：</h4>

<ul>
<li><p>设置签名</p>

<p>利用developer profile或者adhoc distribution profile签名app，注意，不能使用distribution profile方式签名，经过测试，是无法安装的。其中原因个人认为developer profile和adhoc distribution profile都可以指定设备，跟之前了解到的，个人开发者证书只能在100个设备中实现无线安装是一致的。</p></li>
<li><p>生成arichive</p>

<p>菜单：product->build for->arichiving，然后product->archive，完成后可以在organizer中看到生成的arichive。</p></li>
<li><p>生成ipa</p>

<p>选择刚刚生成的arichive，点击“Distribute&hellip;&ldquo;，弹出如下图界面，选择第二个：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test.png" alt="image" /></p>

<p>选择后点“next”，设置相关参数，如下图：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test1.png" alt="image" /></p>

<ul>
<li>一定要勾选“save for enterprise distribution”，简单解释一下各个参数。</li>
<li>application url,是生成的ipa在服务器的位置；title是安装过程中出现的标题；subtitle暂时不清楚做何用处；large image url 和 smal image url是 安装过程中出现的图标。</li>
<li>点击保存，将生成两个文件：myApp.ipa和myApp.plist。</li>
</ul>
</li>
<li><p>服务器部署</p>

<p>将myApp.ipa和myApp.plist部署到自己服务器，同时在服务器生成一个html文件，目的是点击后打开一个链接，这样ios设备就会执行指令自动安装app了。</p>

<p>mac电脑搭建服务器：</p>

<ul>
<li><p>在mac电脑找到服务器的路径</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test2.png" alt="image" /></p></li>
<li><p>打开Documents如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test3.png" alt="image" /></p></li>
<li><p>把三个文件放到Documents就可以了：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test4.png" alt="image" /></p></li>
<li><p>在终端输入如下命令行：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test5.png" alt="image" /></p></li>
<li><p>在网页上输入<code>http://您电脑ip/xxx.html</code>,就OK了</p></li>
</ul>


<p>在html要打开连接内容地址：</p>

<pre><code>itms-services://?action=download-manifest&amp;url=http://192.168.5.7:8080/myApp.plist
</code></pre></li>
</ul>


<p> <strong>说明</strong></p>

<ul>
<li>无需iTunes，无线发布iOS App</li>
<li>不用设备授权即可直接安装，并且不限设备上限</li>
</ul>


<h3>TestFlight</h3>

<p>Testflight是移动团队必备的测试工具</p>

<h4>发布流程:</h4>

<ul>
<li>首先，需要在<a href="https://testflightapp.com">https://testflightapp.com</a>上注册一个账号</li>
<li>然后创建一个team（项目）后邀请一个email</li>
<li>对方在手机上使用safari打开email里的邀请链接，注册一个账号，或登录。对方在手机上一步一步继续按照提示，会要求在手机的设置里安装一个证书。最后这样就是接受了要求。</li>
<li>而你的email里，或在控制面板上可以知道对方的串号。</li>
<li>接着在开发者账号里添加这个串号，重新打包ipa。</li>
<li>在TestFlight的Build界面update，上传这个ipa，并且选择相应的user，选择更新。</li>
<li>最后对方在手机上就可以直接收到提示有新的app，点击安装即可。</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>TestFlight可以收集测试过程中的Crash log，出现的bug，以及测试人员的反馈</li>
<li>方便在于省却了测试员和客户的繁琐操作，但程序员的任务还是一样多</li>
<li>User会有两种角色，一种是Developer，一种是test。test就是只能安装app，而Developer可以更新新的app</li>
<li>越狱的手机是无法通过TestFlight安装app的</li>
</ul>


<h3>FIR.IM</h3>

<p>FIR是一个免费App托管平台, 全名 Fly It Remotely. 可以2步简单发布应用程序, 极大简化了App内测(Ad-Hoc)的过程.</p>

<h4>发布流程：</h4>

<ul>
<li>将安装包拖拽至发布平台 (最大支持 100MB app 文件)</li>
<li>告诉测试人员对应生成的短链地址 (可自定义，同一个 App，有更新也会保持同一个地址，除非你想改动)，然后他们就可直接下载应用安装到手机上了</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>开发者也可在手机上打开 FIR 主页，直接提交已经上线至 App Store 的应用链接，上传成功后也会显示 App 的基本信息，包括版本、图标、更新日期等</li>
<li>测试人员也不用去下个专门获取 UDID 的应用，直接用 Safari 打开 fir.im 主页就可以了</li>
</ul>


<h3>蒲公英</h3>

<h4>发布流程：</h4>

<ul>
<li>将应用上传到网站，生成安装链接和二维码</li>
<li>用户在手机上打开安装链接，或扫码二维码，即可开始安装</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>免费应用托管平台：快速发布应用程序, 极大简化了应用内测过程。通过遍布全国数十家CDN加速节点，提供飞一般的下载速度！</li>
<li>iOS应用企业签名：为iOS应用提供企业签名发布功能。开发者无需拥有299$的企业账号，也可以获得企业签名功能。企业签名的应用，可以直接被所有iOS设备安装。免越狱，免AppStore！</li>
<li>支持iOS和Android应用：无论是Android还是iOS的应用，上传到蒲公英后，瞬间即可生成安装页面</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS真机调试]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/02/ioszhen-ji-diao-shi/"/>
    <updated>2014-07-02T09:15:48+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/02/ioszhen-ji-diao-shi</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/zhenjicheshi.gif" alt="image" /></p>

<!--more-->


<h1>准备工作</h1>

<h5>苹果真机调试需要证书（<strong>Certificates</strong>）和描述文件（<strong>Provisioning Profiles</strong>）</h5>

<ol>
<li>证书（<strong>Certificates</strong>）: 通过苹果系统自带的<strong>钥匙串</strong>生成后上传到<strong>Developer</strong>中在生成来完成</li>
<li><p>描述文件（<strong>Provisioning Profiles</strong>）生成描述文件时需要选择App ID、证书（<strong>Certificates</strong>）、 设备（<strong>Devices</strong>）</p>

<pre><code>App ID 包含Bundle，必须与你程序的bundle保持一致，为了能同时调试多个程序，一般bundle填写时末尾*用号代替
App ID,证书,描述文件,设备,以及你所要调试程序的Bundle Identifier保持一致
</code></pre></li>
</ol>


<h5>进入申请界面</h5>

<p>打开<a href="https://developer.apple.com/devcenter/ios/index.action">iOS Dev Center</a>,选择Sign in，登陆（至少99美元账号），登陆之后在网页右边找到iOS Developer Program,选择Certificates，Identifiers &amp; Profiles，选择Identifiers</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/1.png" alt="image" /></p>

<h5>添加App ID</h5>

<p>选择Identifiers->App IDs,在右侧选择添加按钮添加</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/2.png" alt="image" /></p>

<p>App ID由用.符号分开的两部分组成，在默认情况下，App ID的前缀为你的团队ID，后缀被定义为一个bundle ID的搜索字符串，AppID的每一个部分对你的应用程序都有不同而且很重要的用途</p>

<ul>
<li>App ID Description：这部分只是你ID的一个代号，只需填写一个自己能分辨的名称即可，在后面申请证书和描述文件中会涉及到选择项</li>
</ul>


<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/3.png" alt="image" /></p>

<ul>
<li>App ID Prefix：这部分是Team ID，系统默认，无需填写</li>
<li><p>App ID Suffix：这部分是App ID后缀，可选择Explicit App ID或者Wildcard App ID</p>

<ul>
<li>Explicit App ID</li>
</ul>


<p>Explicit App ID：如果你打算将应用程序中加入Game Center，或在应用中使用应用内购买，进行数据保护，使用iCloud，或者想要给你的应用程序一个唯一的配置文件，你就必须申请Explicit App ID。</p>

<p>要创建Explicit App ID，在下面的框中输入一个唯一的字符串，这个字符串必须与你的应用程序的Bundle ID匹配，苹果推荐使用 com.你的公司名称.app名称作为你的Bundle ID，如果是选择Explicit App ID，Bundle ID中 不能含有*号</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/4.png" alt="image" /></p>

<ul>
<li>Wildcard App ID：通用App ID，只需使用com.oschina.*的格式即可匹配多个应用，本文以通用型为例</li>
</ul>


<p>Wildcard App ID：可以让你用一个App ID来匹配多个App，想要创建一个通用App ID，在输入Bundle ID末尾使用*号</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/5.png" alt="image" /></p></li>
<li><p>App Services：应用程序提供的服务</p>

<p>App Services：选择你应用中将会使用的服务，在App ID注册成功之后也可再次编辑你的选择在自己应用中所使用到的选项上打√，因为我选择的是通用型（WildCard)，所以Game Center，In-App Purchase， Push Notifications都是不可选的，如果要使用这些功能，请选择精确型(Explicit)</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/6.png" alt="image" /></p></li>
</ul>


<p>完成上面的填写之后，选择Continue</p>

<ul>
<li><p>确认信息</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/7.png" alt="image" /></p>

<p>确认之后选择Submit，出现Registration complete.的字样，选择Done即可</p></li>
</ul>


<h4>添加设备（Devices）</h4>

<ul>
<li>将设备连上电脑，打开在XCode的Organizer->Devices中</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitBook]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook/"/>
    <updated>2014-06-30T15:10:45+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/gitbook.png" alt="image" /></p>

<!--more-->


<h1>序言</h1>

<h2>文档</h2>

<p>这本书包含GitBook和GitBook.io整个文档。在GitHub允许你改进这个文档。</p>

<p>GitBook是一个工具来构建好的书同时也克使用Git和markdown。你的书可以生成多种格式:</p>

<ul>
<li><strong>Static Website</strong> :这是默认格式,它生成一个完整的交互式静态网站</li>
<li><strong>PDF</strong> :一个完整的PDF和书后的练习解答</li>
<li><strong>eBook</strong> :一个完整的PDF和书后的练习解答</li>
</ul>


<p>GitBook是开放源代码的,完全免费,工具的源代码可以在GitHub上。</p>

<h2>需要帮助</h2>

<p>我们总是乐意帮忙你的书或其他任何你可能有问题。你可以问一个问题或发表在GitHub问题上一个问题或通过电子邮件与我们联系:contact@gitbook.io。</p>

<h1>编辑器</h1>

<h2>桌面编辑器</h2>

<p>一个用于桌面编辑器。它是开放源代码的,可以在GitHub的源代码。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h2>下载</h2>

<p>这些平台的编辑器可以下载：</p>

<ul>
<li>Windows</li>
<li>Mac OS</li>
<li>Linux 32bits</li>
<li>Linux 64bits</li>
</ul>


<h2>关联你的GitBook.io账户</h2>

<p>你可以容易连接GitBook.io账户通过在身份对话框中输入您的用户名和密码的身份验证对话框:</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h1>格式</h1>

<p>GitBook的使用规范是在基于markdown文件。
一本书是一个Git存储库包含至少2文件:README.md和SUMMARY.md</p>

<h3>README.md</h3>

<p>通常情况下,这应该是你的书的介绍。它自动会被添加到最后的总结中。</p>

<h3>SUMMARY.md</h3>

<p>这个SUMMARY.md定义你的书结构。它应该包含一个章节列表,链接到各自的页面。</p>

<p>例子：</p>

<pre><code>* [English](en/)
* [French](fr/)
* [Español](es/)
</code></pre>

<p>文件不包含在SUMMARY.md中将不会被gitbook处理。</p>

<h2>多语言</h2>

<p>GitBook支持用多种语言编写的书籍。在标准GitBook格式下，每种语言应该是子目录和一个文件命名为LANGS.md应该出现在库的根目录中使用以下格式:</p>

<pre><code># Summary
This is the summary of my book.
* [section 1](section1/README.md)    
    * [example 1](section1/example1.md)    
    * [example 2](section1/example2.md)
* [section 2](section2/README.md)    
    * [example 1](section2/example1.md)
</code></pre>

<p>你可以看到一个完整的示例通过 Learn Git书。</p>

<h2>忽略文件和文件夹</h2>

<p>GitBook 将阅读.gitignore .bookignore和.ignore 文件，跳过文件和文件夹的列表。(这些文件的格式,和.gitignore一样遵循相同的规范)</p>

<h1>发表内容</h1>

<p> 当你的书是gitbook.io创建的,你需要发表一些内容。</p>

<h2>使用编辑器</h2>

<p>如果你还没有编辑器,<a href="http://help.gitbook.io/editor/README.html">免费安装</a>。</p>

<p>连接你的GitBook.io账户编辑器。您可以使用菜单<code>Book &gt;Publish</code> 去更新你的书的内容。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/publish.png" alt="image" /></p>

<h2>使用Git</h2>

<p>你可以使用git去发表和更新你的书</p>

<pre><code>$ git push https://push.gitbook.io//.git
</code></pre>

<p>它将会提示你的用户名(用户名或者邮件)和密码(密码或者api token)</p>

<h2>下一步</h2>

<p>一旦你把内容发布到GitBook.io,您需要检查您的构建的状态。</p>

<p><strong><a href="http://help.gitbook.io/book/build.html">了解更多</a></strong></p>

<h1>构建</h1>

<p>通过使用<strong>git</strong>或者<strong>编辑器</strong>发布内容后,GitBook.io将开始不同的构建:</p>

<ul>
<li><strong>website</strong>:它将生成的网站</li>
<li><strong>json</strong>:它将提取关于这本书的元数据(摘要、介绍…)</li>
<li><strong>epub</strong>:它将生成epub下载</li>
<li><strong>pdf</strong>:它将生成pdf下载</li>
</ul>


<h2>构建列表</h2>

<p>你书中<strong>活动选项卡</strong>让你遵循构建的演变</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/activity.png" alt="image" /></p>

<h2>构建细节</h2>

<p>当点击构建连接“logs”，你可以访问一个细节页面。本页面将会让你看到构建过程的输出。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/build.png" alt="image" /></p>

<h2>修正错误</h2>

<p>如果构建失败,您可以使用日志来调试这个问题和发布一个确定的内容。</p>

<p><strong><a href="http://help.gitbook.io/book/errors.html">了解更多关于常见错误</a></strong></p>

<h1>常见错误</h1>

<p>这是一个常见构建错误列表</p>

<hr />

<pre><code>Error loading plugins: plugin1, ...
</code></pre>

<p>这个错误是发生因为Gitbook不能解决一个插件(或插件是无效的)。外部插件需要被指定到node.js 依赖字段中package.json文件。了解更多关于package.json格式。</p>

<p>例如,如果你的书依赖于Autocover插件,您需要一个package.json文件包含以下内容:</p>

<pre><code>{
    "name": "mybook",
    "version": "0.0.0",
    "description": "",
    "repository": {
        "type": "git",
    "url": "https://github.com/Me/mybook.git"
      },
    "author": "Me &lt;me@gmail.com&gt;",
    "dependencies": {
    "gitbook-plugin-autocover": "0.0.5"
    }
}
</code></pre>

<h1>封面</h1>

<p>为了让你的书在GitBook.io更加优雅，你可以指定一个封面。</p>

<p>一个封面被指定是<strong>cover.jpg</strong>文件，一个<strong>cover_small.jpg</strong>也可以存在作为一个封面更小的版本。封面应该是一个<strong>JPEG</strong>文件。</p>

<h2>合适大小</h2>

<table class="table table-bordered table-striped table-condensed">
<tr>
<td></td>
<td>Big</td>
<td>Small</td>
</tr>
<tr>
<td>File</td>
<td>cover.jpg</td>
<td>cover_small.jpg</td>
</tr>
<tr>
<td>Size</td>
<td>1800x2360</td>
<td>200x262</td>
</tr>
</table>


<h2>自动封面</h2>

<p>GitBook插件(autocover)也可以用来生成一个封面文件,或者只是生成cover_small.jpg从你大的封面。</p>

<p><strong><a href="https://github.com/GitbookIO/plugin-autocover">了解更多的自动封面</a></strong></p>

<h2>指南</h2>

<p>一个好的封面遵守一下指南：</p>

<ul>
<li>没有边框</li>
<li>清晰可见的文本标题</li>
<li>在小版本上重要文本也可见</li>
</ul>


<h1>定制域名</h1>

<p>在<strong>Gitbook.io</strong>上所有的书可以通过<a href="http://.gitbooks.io/{book}/">http://.gitbooks.io/{book}/</a>.链接地址访问</p>

<p>不过你也能配置你的书使用一个自定制的域名（一个免费功能在GitBook.io）</p>

<p>添加一个自定制域名的书过程是很容易的。</p>

<ol>
<li>添加你的域名在你的书中设置.为了使用您自己的域名,你需要改变你的域名注册:</li>
<li>登录到你的域名注册和找允许您添加/编辑主机记录部分,经常发现在设置菜单“编辑DNS”,“主机记录”或“区域文件控制”。</li>
<li>设置www记录一个CNAME和URL字段设置为:www.gitbook.io。</li>
<li>把naked域(yourdomain.com)重定向到www.yourdomain.com,把这个选择指向这个域名。这通常被发现在“转发”,“URL转发”或“URL重定向”。</li>
</ol>


<p>可能需要几个小时为域名的变化。检查是否准备好或设置与GitBook定制域,输入您的域名(包括www)如下:</p>

<h1>可见性</h1>

<h2>公共/私人</h2>

<p>你的书可以<strong>公共</strong>或<strong>私人</strong>。公共图书对每个人都可见但只有collaborators 可以更新它。私人书籍只对collaborators可见。
　　
你可以把你的书从公共转换私人和从私人到公共。</p>

<h2>支付书</h2>

<p>书籍只能公共支付。</p>

<h2>Home /探索页面</h2>

<p>首页和探索页面包含书列表已经成功建造。我们建议设置封面图片。</p>

<h1>练习和测试</h1>

<h2>练习</h2>

<p>一本书可以包含互动练习(目前只在Javascript)。是一个代码的挑战提供给读者的练习,这是给定一个代码编辑器编写解决方案,检查对这本书作者的验证代码。</p>

<p>一个练习由4部分组成：</p>

<ul>
<li>练习<strong>留言</strong>/目标(在markdown/文本)</li>
<li><strong>初始代</strong>码显示给用户,提供一个起点</li>
<li><strong>解决方案</strong>的代码,是一个正确的解决方案</li>
<li><strong>验证</strong>代码,测试用户的输入的正确性</li>
</ul>


<p>练习需要开始和完成带有分隔标识(<code>——</code>或<code>* * *</code>)。它应该包含3代码元素(<strong>基地</strong>,<strong>解决方案</strong>和<strong>验证</strong>)。它可以包含第4元素来提供<strong>上下文</strong>代码(函数,导入库等…不应该显示给用户)。</p>

<pre><code>---

Define a variable `x` equal to 10.

```js
var x =
```

```js
var x = 10;
```

```js
assert(x == 10);
```

```js
// This is context code available everywhere
// The user will be able to call magicFunc in his codefunction magicFunc() {  
  return 3;
  }```

  ---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/new.png" alt="image" /></p>

<h2>测验</h2>

<p>一本书可以包含互动测验
在和练习的相同方式下测验也可以被定义</p>

<pre><code>---

Here is the introduction for the quiz

This is Question 1:
- [x] This is the proposition 1 (the correct one)
- [ ] This is the proposition 2

&gt; This is a help message when the answer to question 1 is wrong

This is Question 2:
- [ ] This is the proposition 1
- [x] This is the proposition 2 (correct)
- [x] This is the proposition 3 (correct)

&gt; This is a help message when the answer to question 2 is wrong

---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/result.png" alt="image" /></p>

<h1>谷歌Authorship</h1>

<p>使用Authorship能提高书籍的搜索结果。
　　
GitBook链接到谷歌作者必须先登录或创建一个Google +概要。
　　</p>

<ul>
<li>连接你的Google帐户<a href="https://www.gitbook.io/settings">设置</a>。</li>
<li>进入关于你G +的页面。</li>
<li>发现底部的“链接”章节。</li>
<li>在章节“链接”有三个选项。“其他配置文件”、“贡献者”,和“链接”。</li>
<li>点击“添加自定义链接”的“贡献者”一节&amp;命名为“GitBook”“标签”字段</li>
<li>Gitbook概要文件的URL添加到URL字段(<a href="https://www.gitbook.io/@twitter_username">https://www.gitbook.io/@twitter_username</a>)</li>
<li>点击保存并返回你的G +概要文件</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/29/swift/"/>
    <updated>2014-06-29T15:10:36+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/29/swift</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/29/swift.png" alt="image" /></p>

<!--more-->


<p>Swift一种编译式编程语言,由苹果公司推出,用来撰写OS X和iOS应用程序。2014年,在AppleWWDC所发布,设计Swift时,苹果公司有意让Swift与Objective-C共存在苹果公司的操作系统上。</p>

<h3>历史</h3>

<p>2010年7月,苹果开发者工具部门总监克里斯·拉特纳开始着手Swift编程语言的设计工作,以一年时间,完成基本架构后,他领导了一个设计团队大力参与其中。Swift大约历经4年的开发期,2014年6月发表。
苹果宣称Swift的特点是:快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译,可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果,能让Swift源代码在撰写过程中能实时显示出其运行结果。拉特纳本人强调,Playgrounds很大程度是受到布雷特·维克多（Bret Victor）理念的启发。</p>

<h3>特色</h3>

<p>Swift取消了Objective C的指针及其他不安全访问的使用,并舍弃Objective C早期套用Smalltalk之语法,全面改为句点表示法（dot-notation）。同许多script语言一样,Swift可以推断变量类型（var, variant）。同时,它提供了类似Java的命名空间(namespace)、泛型(generic)、运算对象重载（operator overloading）。Swift被简单的形容为 “没有C的Objective-C”（Objective-C without the C）。</p>

<h3>类型与变量</h3>

<p>在Cocoa与Cocoa Touch的环境下,许多共用的类物都放在Foundation Kit库下,这些类型包含了NSString字符串库 (使用 Unicode), 还有集合类型 NSArray 与 NSDictionary。Objective-C 提供了语法糖（syntactic sugar）的方式让这些对象可以集成在同一个语言里。例如NSString之间合并的表示法如下:</p>

<pre><code>NSString *str = @"hello,";
str = [str stringByAppendingString:@" world"];  
</code></pre>

<p>在Swift里, 字符串的累积可以用加法（+）运算对象作为第一级公民（First-class citizen）的方式直接完成, 上述的例子可以简化为</p>

<pre><code>var str = "hello,"; str += " world"
</code></pre>

<p>过去Cocoa（以及Cocoa Touch）的架构总是被分成两种版本，一种是可变的（mutable）,也就是可以在运行时期（runtime）改变；另一种是不可变的（immutable）,其初始值不可改变,例如NSArray与MSMutableArray就是数组的两种版本。在Swift语言的世界里仍延续这个传统,但更简化为使用 let 关键字去设置常数（constant variable）。至于可变的(Mutable)对象则使用var关键字。Swift语言使用类似C#或Javascript的var定义变量,但特性又不尽相同,Swift不会直接指派初始值给变量,亦即变量不会有默认值,所以使用var变量之前必须先初始化，不然会发生编译时期的错误。</p>

<p>为了方便使用,Swift还提供Optional的定义来声明nil-free references。声明Optional只需要在类型后面加上问号(?)即可。一旦var变量声明为Optional的，其初始值就会被默认为nil。Optional本质上是enum，有定义None和Some两种类型，nil即是Optional.None。</p>

<h3>库、运行时期与部署</h3>

<p>Swift在 Mac OS 和 iOS 平台可以和Object-C使用相同的运行时期(runtime)。这意味着Swift 程序可以运行于目前已存在的平台之上，包含 iOS 6 和 OS X 10.8 都可以运行Swift的程序。 更重要的, Swift 和 Obj-C 的代码可并存于单一程序内, 这种延伸就如同C 和 C++ 的关系一样。</p>

<p>为了争取大量的开发人员并重复使用已存在的代码, Xcode 6 允许在app target导入Objective-C文件供给Swift使用，通过Objective-C的桥接头文件（bridging header）来暴露给 Swift。当开发人员添加 Swift 文件到现有的Objective-C应用程序时，Xcode 会自动创建这些头文件。例如, 一个Swift 知名的类型 &ldquo;MyClass&rdquo; 可用于 Obj-C 的方式 #import &ldquo;MyClass-Swift.h&#8221;。</p>

<h3>存储器管理</h3>

<p>Swift全面使用自动引用计数(ARC)来管理存储器,取代过去Objective C的垃圾回收功能。过去在Objective-C中,强引用(strong reference)即为非ARC中的retain,而弱引用(weak reference)即为非ARC中的assign. 为了解决循环引用的问题,Swift提供unowned, 不能设定为optional types，不能加上问号(?)或惊叹号(!)。</p>

<h3>除错以及其他元素</h3>

<p>Xcode的除错机制针对Swift语言提供REPL（Read-Eval-Print Loop, 这是源自emacs的术语）环境,可以利用Swift语法来评估或与其他程序交互，使Swift编程具有类似Python与Ruby交互性接口（Interactive Shell）。</p>

<h3>类似Objective-C之处</h3>

<ul>
<li>基本数值类型（numeric types）大致相同 (例如Int, UInt, Float, Double)</li>
<li>大量的C 运算对象被移出Swift, 但又引入一些新运算对象。</li>
<li>大括号被用于组群陈述（group statements）。</li>
<li>变量之赋值使用等于符号, 但比较则使用“连续两个等于”(==)运算对象。还有一个新的运算对象，“连续三个等于”(===)被用来判断常数或变量之间是否为同一对象之实例(instance)。</li>
<li>中括号([], Square brackets)用于数组的表示, 声明阵例之后, 可以指派索引值(index)来进行元素(element)之访问。</li>
<li>控制陈述（control statement）, for, while, if, switch 与Ojbective-C都十分类似, 但有延伸功能, 像是 for in 用于集合(collection)的轮询, switch 还可以接受非整数的cases条件值, 诸如此类。</li>
</ul>


<h3>不同于Objective-C之处</h3>

<ul>
<li>陈述句（statement）不须再使用分号 (&lsquo;;&rsquo;)做为退出, 但分号还是可以在一行以内作为两个以上陈述的分隔。</li>
<li>头文件(Header files)不再需要。</li>
<li>注解方式 /<em> &hellip; </em>/ 可以为嵌套（nested）注解, 意思是指注解内可以再有注解, 过去有些C或C++编译器不支持嵌套注解。</li>
<li>强类型(strong type)</li>
<li>类型推论或隐含类型(Type inference)</li>
<li>支持泛型编程。</li>
<li>函数为第一等类型(first-class object)，这意味着函数可以作为其他函数的参数与返回值。</li>
<li>运算对象可在类型内重新定义 (运算对象重载)。可以生成新的运算对象。</li>
<li>字符串全方面支持 Unicode。某些字符甚至可以成为语言的名称。</li>
<li>许多C语言家族过去恶名昭彰的怪语法（error-prone behaviors）也被改变:

<ul>
<li>不再存在指针。</li>
<li>指派(Assignments)不再回传值。正确写法是 if (i==0) ，一般容易误写成 if (i=0) 会造成编译时期错误(compile-time error)。</li>
<li>在switch 的区块内不需要再使用 break 叙述句。另外, case后面都需要有可执行的代码（C或C++可连续使用多个case而不需要额外的代码）, 否则会发生编译错误。</li>
<li>变量和常数都要被初始化，而且数组(array)的界限也要确认清楚。</li>
<li>溢出（overflows）的问题。C语言没有强制整数类型（signed integers）的界限, 常常在运行时间发生问题。Swift可以通过整数类型的max或min属性取得最大值或最小值。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mae Blog]]></title>
  <link href="http://zhouhongmeiblog.github.io/atom.xml" rel="self"/>
  <link href="http://zhouhongmeiblog.github.io/"/>
  <updated>2014-08-28T13:45:23+08:00</updated>
  <id>http://zhouhongmeiblog.github.io/</id>
  <author>
    <name><![CDATA[maebook]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ios学习笔记－开源框架和类]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/08/26/iosxue-xi-bi-ji-%5Bnil%5Dkai-yuan-kuang-jia-he-lei/"/>
    <updated>2014-08-26T17:57:35+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/08/26/iosxue-xi-bi-ji-[nil]kai-yuan-kuang-jia-he-lei</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li><p>SDWebImage,UIImageView+WebCache加载一张图片。</p></li>
<li><p>UIViewExt用于定位坐标系统很有用。可以直接拿到bottom，top，left，right</p></li>
<li>CustomCatagory,是个类目，里面有navigationBar和UINavigationController的两种系统版本下自定义navigationBar背景图片方法，用于自定义navigationBar背景图片。</li>
<li>UIUtils工具类，里面我写了四个方法，一个获取documents下路径，一个将NSDate类型转换为字符串类型，一个将字符串转换为NSDate类型，还有一个将传进来的一个评分字符串分割开成两个，放在数组中，用于显示两个不同字体类型的评分。</li>
<li>CONSTS常量类，里面存放的是整个项目中需要使用的常量，写成宏形式。</li>
<li>UIFactory里面自定义了button类型，两种常用的button样式。</li>
<li>JSONKit类用于json数据解析</li>
<li>ASIHTTPRequest开源库，用于请求网络，需要依赖这五个系统自带库CFNetWork,SystemConfiguration,MobileCoreServices,和libz，libxml2.</li>
<li>DataSevrice网络请求类，分GET和POST请求两种方式，使用HTTP请求网络，使用ASIFormDataRequst类，需要一个url参数，当使用GET请求使用，不需要字典参数，增加一个请求头，当使用POST请求的时候需要一个字典参数，通过键key发送值。</li>
<li>转化成model对象类，将请求下来的网络数据字典转换为model对象，方便在其他类之间进行数据传输。</li>
<li>自定了一个单例类，将项目中需要在控制器之间传输的数据存取起来，方便调用。</li>
<li>使用OpenFlow开源框架，用于显示首页的图片要实现效果，在AFItemView类里面设置高清和低清两种样式，实现里面三个代理方法，一个用于图片切换时改变，一个用于请求加载图片。通过_operationQueue创建一个线程进行图片加载，可能造成线程堵塞。</li>
<li>EGORefreshTableHeaderView用于上拉下拉刷新，实现里面的几个代理方法，当手指放开时候会去跳用加载数据代理方法。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zip压缩和解压缩]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/23/zipya-suo-he-jie-ya-suo/"/>
    <updated>2014-07-23T13:59:37+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/23/zipya-suo-he-jie-ya-suo</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/23/zip.png" alt="image" /></p>

<!--more-->


<p>这篇文章我将演示如何在你的ios应用程序内部压缩和解压缩文件。我们将使用第三方库称为ZipArchive做到这点。虽然有几个解决方案压缩和解压缩文件，我觉得ZipArchive库是最快、最容易方式运行。</p>

<h2>为什么我要解压缩文件</h2>

<p>这是个好问题。有许多原因为什么在你的应用想要支持压缩和解压缩。这里有些原因：</p>

<h3>苹果App Store的50M下载限制</h3>

<p>苹果公司出于流量的考虑，规定在非WIFI环境下，限制用户只能下载小于50M的应用或游戏。这样一来，对于一些数据或数据包较大的应用，我们只能尽量减小 应用二进制包的体积。而把数据打包到zip中，这样App可以通过网络下载数据包，解压出所需要的内容，而且这样也可以动态的更新内容。</p>

<h3>动态更新内容</h3>

<p>这一点在上面已经提过了。如果应用所需要的资源需要动态更新，一种常见的做法是更新资源，重新打包，重新提交到App store，这样做你需要等待漫长的审核、上架时间。一般情况下是一周左右的时间。更好的方法是将这些资源打包放置在服务器上，App从服务器（或者云存储上下载，然后解压。这样做的好处显而易见，那就是可以快速更新，动态更新，不需要重新打包、上传、审核，省时省力。</p>

<h3>从web上下载zip文件</h3>

<p>Safari和邮件程序都不支持zip的查看，通过ZipArchive你就可以为你的设备增加查看zip文件的能力了，尽管App Store里已经有一些App支持这些功能了。</p>

<h3>建立工程</h3>

<p>首先从google code上check out一份代码，svn地址是：<a href="http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only">http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only</a></p>

<p>在终端中输入如下命令即可check out了：</p>

<p>svn co <a href="http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only">http://ziparchive.googlecode.com/svn/trunk/ziparchive-read-only</a>
或者直接从<a href="http://ziparchive.googlecode.com/files/ZipArchive.zip%E4%B8%8B%E8%BD%BD%E3%80%82">http://ziparchive.googlecode.com/files/ZipArchive.zip%E4%B8%8B%E8%BD%BD%E3%80%82</a></p>

<p>把minizip文件夹和ZipArchive.h以及ZipArchive.mm文件添加到你的工程中。</p>

<p>因为ZipArchive不支持ARC，所以如果你的工程开启了ARC，那么就需要对ZipArchive设置一下。在ZipArchive.mm编译选项中，增加-fno-objc-arc即可。</p>

<p>最后，需要为工程链接libz动态链接库。</p>

<p>至此，ZipArchive已经集成到你的工程中了，编译工程，应该可以编译成功。可能会有一些警告，这无关紧要，不影响编译。但是作为一个态度严谨的程序员，我强烈建议你看一下这些警告是怎么出现的，解决它们。请记住：在你的工程中，警告应该和错误一样被严肃处理</p>

<h3>下载和解压缩文件</h3>

<p>接下来就向大家展示在你的工程中如何从网上下载zip文件，解压缩，并读取zip压缩包中的文件内容。处于演示考虑，主要的目的是向大家演示
ZipArchive接口的使用方法，所以代码的错误处理和条件检查并没有做过多的考量，在实际的工程中，还是需要大家自己做更为严格的条件检查和错误处 理工作。</p>

<p>工程中只是在ViewController中增加了一个UIImageView和一个UILabel。我们将从网络上下载zip文件，zip文件中包含一张 图片和一个文本文件。下载解压后，图像会被渲染到UIImageView中，而文本会作为UILabel的内容展示。示例代码在文章末尾。希望读者朋友们 自行下载，编译，查看效果。</p>

<p>好，接下来讲一讲具体的实现：</p>

<h4>引入ZipArchive的头文件</h4>

<p> import &ldquo;ZipArchive.h&rdquo;</p>

<h4>下载zip文件</h4>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(
    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_async(queue, ^{
        NSURL *url = [NSURL URLWithString:@"http://www.icodeblog.com/wp-content/uploads/2012/08/zipfile.zip"];
        NSError *error = nil;
    // 2
        NSData *data = [NSData dataWithContentsOfURL:url options:0 error:&amp;error];

        if(!error)
        {        
        // 3
            NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
             NSString *path = [paths objectAtIndex:0];
             NSString *zipPath = [path stringByAppendingPathComponent:@"zipfile.zip"];

            [data writeToFile:zipPath options:0 error:&amp;error];

            if(!error)
            {
            // TODO: Unzip
            }
            else
            {
            NSLog(@"Error saving file %@",error);
            }
        }
        else
        {
        NSLog(@"Error downloading zip file: %@", error);
    }

});
</code></pre>

<p>  说明：上面这段代码的主要作用就是从iCodeBlog上下载一个zip文件，并写入到应用的缓存目录中。</p>

<p>现在zip文件已经下载下来了，接下来就是要解压缩，并将解压缩出来的文件利用起来。</p>

<h4>解压缩已下载的zip文件</h4>

<p>在第二步中，我们已经把zip文件下载到/Library/Caches/zipfile.zip，现在来解压缩。</p>

<p>把上面代码中的//TODO: Unzip用下面的代码替换掉。</p>

<pre><code>ZipArchive *za = [[ZipArchive alloc] init];
// 1
if ([za UnzipOpenFile: zipPath]) {      
// 2      
BOOL ret = [za UnzipFileTo: path overWrite: YES];
if (NO == ret){} [za UnzipCloseFile];

// 3
NSString *imageFilePath = [path stringByAppendingPathComponent:@"photo.png"];
NSString *textFilePath = [path stringByAppendingPathComponent:@"text.txt"];
NSData *imageData = [NSData dataWithContentsOfFile:imageFilePath options:0 error:nil];
UIImage *img = [UIImage imageWithData:imageData];
NSString *textString = [NSString stringWithContentsOfFile:textFilePath 
    encoding:NSASCIIStringEncoding error:nil];

// 4           
dispatch_async(dispatch_get_main_queue(), ^{
    self.imageView.image = img;
    self.label.text = textString;
});
</code></pre>

<p>  说明：</p>

<ul>
<li>在内存中解压缩文件</li>
<li>将解压缩的内容写到缓存目录中</li>
<li>使用解压缩后的文件</li>
<li>更新UI</li>
</ul>


<h3>压缩文件</h3>

<p>接下来看一下怎么进行文件压缩。在上面的步骤中，我们已经把一个zip文件解压缩到缓存目录中。现在我们再把解压缩出来的文件重新压缩为一个zip文件，并把这个zip文件写入到Documents目录里去（OMG，这两个文件太惨了，被反复蹂躏）</p>

<p>在示例工程代码中，我已经增加了一个按钮，并和一个IBAction相关联，按钮的处理函数名为zipFilesBUttonPressed:，具体代码如下：</p>

<pre><code>- (IBAction)zipFilesButtonPressed:(id)sender
{
    // 1
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docspath = [paths objectAtIndex:0];

   // 2
     paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
    NSString *cachePath = [paths objectAtIndex:0];

  // 3
    NSString *zipFile = [docspath stringByAppendingPathComponent:@"newzipfile.zip"];       

 // 4
    ZipArchive *za = [[ZipArchive alloc] init];
    [za CreateZipFile2:zipFile];

// 5
     NSString *imagePath = [cachePath stringByAppendingPathComponent:@"photo.png"];
     NSString *textPath = [cachePath stringByAppendingPathComponent:@"text.txt"];

// 6
    [za addFileToZip:imagePath newname:@"NewPhotoName.png"];
    [za addFileToZip:textPath newname:@"NewTextName.txt"];

// 7
    BOOL success = [za CloseZipFile2];    
    NSLog(@"Zipped file with result %d",success);
}
</code></pre>

<p>   说明：</p>

<ul>
<li><p>获取Documents目录，新的zip文件要写入到这个目录里。</p></li>
<li><p>获取Caches目录，要进行压缩的文件在这个目录里。</p></li>
<li><p>获取zip文件的全路径名。</p></li>
<li><p>创建一个ZipArchive实例，并创建一个内存中的zip文件。需要注意的是，只有当你调用了CloseZipFile2方法之后，zip文件才会从内存中写入到磁盘中去。</p></li>
<li><p>获取要被压缩的文件的全路径</p></li>
<li><p>把要压缩的文件加入到zip对象中去，加入的文件数量没有限制，也可以加入文件夹到zip对象中去。</p></li>
<li><p>把zip从内存中写入到磁盘中去。</p></li>
</ul>


<p>当点击按钮之后，在应用的Documents文件夹下应该有一个叫newzipfile.zip的文件。解压这个文件，就能解压出那两个被反复蹂躏的文件来</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 测试解决方案]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/03/distribute-app/"/>
    <updated>2014-07-03T14:10:19+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/03/distribute-app</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/iOS_Test.png" alt="image" /></p>

<!--more-->


<h3>App内测（Ad-Hoc）</h3>

<p>利用企业级开发证书和提供简单网页服务器搭建文件以及相关技术文档，把文件上传到您的网站，就可以是越狱和非越狱用户在iphone或者ipad上在线直接安装APP软件!</p>

<h4>发布流程：</h4>

<ul>
<li><p>设置签名</p>

<p>利用developer profile或者adhoc distribution profile签名app，注意，不能使用distribution profile方式签名，经过测试，是无法安装的。其中原因个人认为developer profile和adhoc distribution profile都可以指定设备，跟之前了解到的，个人开发者证书只能在100个设备中实现无线安装是一致的。</p></li>
<li><p>生成arichive</p>

<p>菜单：product->build for->arichiving，然后product->archive，完成后可以在organizer中看到生成的arichive。</p></li>
<li><p>生成ipa</p>

<p>选择刚刚生成的arichive，点击“Distribute&hellip;&ldquo;，弹出如下图界面，选择第二个：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test.png" alt="image" /></p>

<p>选择后点“next”，设置相关参数，如下图：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test1.png" alt="image" /></p>

<ul>
<li>一定要勾选“save for enterprise distribution”，简单解释一下各个参数。</li>
<li>application url,是生成的ipa在服务器的位置；title是安装过程中出现的标题；subtitle暂时不清楚做何用处；large image url 和 smal image url是 安装过程中出现的图标。</li>
<li>点击保存，将生成两个文件：myApp.ipa和myApp.plist。</li>
</ul>
</li>
<li><p>服务器部署</p>

<p>将myApp.ipa和myApp.plist部署到自己服务器，同时在服务器生成一个html文件，目的是点击后打开一个链接，这样ios设备就会执行指令自动安装app了。</p>

<p>mac电脑搭建服务器：</p>

<ul>
<li><p>在mac电脑找到服务器的路径</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test2.png" alt="image" /></p></li>
<li><p>打开Documents如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test3.png" alt="image" /></p></li>
<li><p>把三个文件放到Documents就可以了：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test4.png" alt="image" /></p></li>
<li><p>在终端输入如下命令行：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/03/test5.png" alt="image" /></p></li>
<li><p>在网页上输入<code>http://您电脑ip/xxx.html</code>,就OK了</p></li>
</ul>


<p>在html要打开连接内容地址：</p>

<pre><code>itms-services://?action=download-manifest&amp;url=http://192.168.5.7:8080/myApp.plist
</code></pre></li>
</ul>


<p> <strong>说明</strong></p>

<ul>
<li>无需iTunes，无线发布iOS App</li>
<li>不用设备授权即可直接安装，并且不限设备上限</li>
</ul>


<h3>TestFlight</h3>

<p>Testflight是移动团队必备的测试工具</p>

<h4>发布流程:</h4>

<ul>
<li>首先，需要在<a href="https://testflightapp.com">https://testflightapp.com</a>上注册一个账号</li>
<li>然后创建一个team（项目）后邀请一个email</li>
<li>对方在手机上使用safari打开email里的邀请链接，注册一个账号，或登录。对方在手机上一步一步继续按照提示，会要求在手机的设置里安装一个证书。最后这样就是接受了要求。</li>
<li>而你的email里，或在控制面板上可以知道对方的串号。</li>
<li>接着在开发者账号里添加这个串号，重新打包ipa。</li>
<li>在TestFlight的Build界面update，上传这个ipa，并且选择相应的user，选择更新。</li>
<li>最后对方在手机上就可以直接收到提示有新的app，点击安装即可。</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>TestFlight可以收集测试过程中的Crash log，出现的bug，以及测试人员的反馈</li>
<li>方便在于省却了测试员和客户的繁琐操作，但程序员的任务还是一样多</li>
<li>User会有两种角色，一种是Developer，一种是test。test就是只能安装app，而Developer可以更新新的app</li>
<li>越狱的手机是无法通过TestFlight安装app的</li>
</ul>


<h3>FIR.IM</h3>

<p>FIR是一个免费App托管平台, 全名 Fly It Remotely. 可以2步简单发布应用程序, 极大简化了App内测(Ad-Hoc)的过程.</p>

<h4>发布流程：</h4>

<ul>
<li>将安装包拖拽至发布平台 (最大支持 100MB app 文件)</li>
<li>告诉测试人员对应生成的短链地址 (可自定义，同一个 App，有更新也会保持同一个地址，除非你想改动)，然后他们就可直接下载应用安装到手机上了</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>开发者也可在手机上打开 FIR 主页，直接提交已经上线至 App Store 的应用链接，上传成功后也会显示 App 的基本信息，包括版本、图标、更新日期等</li>
<li>测试人员也不用去下个专门获取 UDID 的应用，直接用 Safari 打开 fir.im 主页就可以了</li>
</ul>


<h3>蒲公英</h3>

<h4>发布流程：</h4>

<ul>
<li>将应用上传到网站，生成安装链接和二维码</li>
<li>用户在手机上打开安装链接，或扫码二维码，即可开始安装</li>
</ul>


<p><strong>说明</strong></p>

<ul>
<li>免费应用托管平台：快速发布应用程序, 极大简化了应用内测过程。通过遍布全国数十家CDN加速节点，提供飞一般的下载速度！</li>
<li>iOS应用企业签名：为iOS应用提供企业签名发布功能。开发者无需拥有299$的企业账号，也可以获得企业签名功能。企业签名的应用，可以直接被所有iOS设备安装。免越狱，免AppStore！</li>
<li>支持iOS和Android应用：无论是Android还是iOS的应用，上传到蒲公英后，瞬间即可生成安装页面</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS真机调试]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/07/02/ioszhen-ji-diao-shi/"/>
    <updated>2014-07-02T09:15:48+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/07/02/ioszhen-ji-diao-shi</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/zhenjicheshi.gif" alt="image" /></p>

<!--more-->


<h1>准备工作</h1>

<h5>苹果真机调试需要证书（<strong>Certificates</strong>）和描述文件（<strong>Provisioning Profiles</strong>）</h5>

<ol>
<li>证书（<strong>Certificates</strong>）: 通过苹果系统自带的<strong>钥匙串</strong>生成后上传到<strong>Developer</strong>中在生成来完成</li>
<li><p>描述文件（<strong>Provisioning Profiles</strong>）生成描述文件时需要选择App ID、证书（<strong>Certificates</strong>）、 设备（<strong>Devices</strong>）</p>

<pre><code>App ID 包含Bundle，必须与你程序的bundle保持一致，为了能同时调试多个程序，一般bundle填写时末尾*用号代替
App ID,证书,描述文件,设备,以及你所要调试程序的Bundle Identifier保持一致
</code></pre></li>
</ol>


<h5>进入申请界面</h5>

<p>打开<a href="https://developer.apple.com/devcenter/ios/index.action">iOS Dev Center</a>,选择Sign in，登陆（至少99美元账号），登陆之后在网页右边找到iOS Developer Program,选择Certificates，Identifiers &amp; Profiles，选择Identifiers</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/1.png" alt="image" /></p>

<h5>添加App ID</h5>

<p>选择Identifiers->App IDs,在右侧选择添加按钮添加</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/2.png" alt="image" /></p>

<p>App ID由用.符号分开的两部分组成，在默认情况下，App ID的前缀为你的团队ID，后缀被定义为一个bundle ID的搜索字符串，AppID的每一个部分对你的应用程序都有不同而且很重要的用途</p>

<ul>
<li>App ID Description：这部分只是你ID的一个代号，只需填写一个自己能分辨的名称即可，在后面申请证书和描述文件中会涉及到选择项</li>
</ul>


<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/3.png" alt="image" /></p>

<ul>
<li>App ID Prefix：这部分是Team ID，系统默认，无需填写</li>
<li><p>App ID Suffix：这部分是App ID后缀，可选择Explicit App ID或者Wildcard App ID</p>

<ul>
<li>Explicit App ID</li>
</ul>


<p>Explicit App ID：如果你打算将应用程序中加入Game Center，或在应用中使用应用内购买，进行数据保护，使用iCloud，或者想要给你的应用程序一个唯一的配置文件，你就必须申请Explicit App ID。</p>

<p>要创建Explicit App ID，在下面的框中输入一个唯一的字符串，这个字符串必须与你的应用程序的Bundle ID匹配，苹果推荐使用 com.你的公司名称.app名称作为你的Bundle ID，如果是选择Explicit App ID，Bundle ID中 不能含有*号</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/4.png" alt="image" /></p>

<ul>
<li>Wildcard App ID：通用App ID，只需使用com.oschina.*的格式即可匹配多个应用，本文以通用型为例</li>
</ul>


<p>Wildcard App ID：可以让你用一个App ID来匹配多个App，想要创建一个通用App ID，在输入Bundle ID末尾使用*号</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/5.png" alt="image" /></p></li>
<li><p>App Services：应用程序提供的服务</p>

<p>App Services：选择你应用中将会使用的服务，在App ID注册成功之后也可再次编辑你的选择在自己应用中所使用到的选项上打√，因为我选择的是通用型（WildCard)，所以Game Center，In-App Purchase， Push Notifications都是不可选的，如果要使用这些功能，请选择精确型(Explicit)</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/6.png" alt="image" /></p></li>
</ul>


<p>完成上面的填写之后，选择Continue</p>

<ul>
<li><p>确认信息</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/07/02/7.png" alt="image" /></p>

<p>确认之后选择Submit，出现Registration complete.的字样，选择Done即可</p></li>
</ul>


<h4>添加设备（Devices）</h4>

<ul>
<li>将设备连上电脑，打开在XCode的Organizer->Devices中</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitBook]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook/"/>
    <updated>2014-06-30T15:10:45+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/gitbook.png" alt="image" /></p>

<!--more-->


<h1>序言</h1>

<h2>文档</h2>

<p>这本书包含GitBook和GitBook.io整个文档。在GitHub允许你改进这个文档。</p>

<p>GitBook是一个工具来构建好的书同时也克使用Git和markdown。你的书可以生成多种格式:</p>

<ul>
<li><strong>Static Website</strong> :这是默认格式,它生成一个完整的交互式静态网站</li>
<li><strong>PDF</strong> :一个完整的PDF和书后的练习解答</li>
<li><strong>eBook</strong> :一个完整的PDF和书后的练习解答</li>
</ul>


<p>GitBook是开放源代码的,完全免费,工具的源代码可以在GitHub上。</p>

<h2>需要帮助</h2>

<p>我们总是乐意帮忙你的书或其他任何你可能有问题。你可以问一个问题或发表在GitHub问题上一个问题或通过电子邮件与我们联系:contact@gitbook.io。</p>

<h1>编辑器</h1>

<h2>桌面编辑器</h2>

<p>一个用于桌面编辑器。它是开放源代码的,可以在GitHub的源代码。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h2>下载</h2>

<p>这些平台的编辑器可以下载：</p>

<ul>
<li>Windows</li>
<li>Mac OS</li>
<li>Linux 32bits</li>
<li>Linux 64bits</li>
</ul>


<h2>关联你的GitBook.io账户</h2>

<p>你可以容易连接GitBook.io账户通过在身份对话框中输入您的用户名和密码的身份验证对话框:</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h1>格式</h1>

<p>GitBook的使用规范是在基于markdown文件。
一本书是一个Git存储库包含至少2文件:README.md和SUMMARY.md</p>

<h3>README.md</h3>

<p>通常情况下,这应该是你的书的介绍。它自动会被添加到最后的总结中。</p>

<h3>SUMMARY.md</h3>

<p>这个SUMMARY.md定义你的书结构。它应该包含一个章节列表,链接到各自的页面。</p>

<p>例子：</p>

<pre><code>* [English](en/)
* [French](fr/)
* [Español](es/)
</code></pre>

<p>文件不包含在SUMMARY.md中将不会被gitbook处理。</p>

<h2>多语言</h2>

<p>GitBook支持用多种语言编写的书籍。在标准GitBook格式下，每种语言应该是子目录和一个文件命名为LANGS.md应该出现在库的根目录中使用以下格式:</p>

<pre><code># Summary
This is the summary of my book.
* [section 1](section1/README.md)    
    * [example 1](section1/example1.md)    
    * [example 2](section1/example2.md)
* [section 2](section2/README.md)    
    * [example 1](section2/example1.md)
</code></pre>

<p>你可以看到一个完整的示例通过 Learn Git书。</p>

<h2>忽略文件和文件夹</h2>

<p>GitBook 将阅读.gitignore .bookignore和.ignore 文件，跳过文件和文件夹的列表。(这些文件的格式,和.gitignore一样遵循相同的规范)</p>

<h1>发表内容</h1>

<p> 当你的书是gitbook.io创建的,你需要发表一些内容。</p>

<h2>使用编辑器</h2>

<p>如果你还没有编辑器,<a href="http://help.gitbook.io/editor/README.html">免费安装</a>。</p>

<p>连接你的GitBook.io账户编辑器。您可以使用菜单<code>Book &gt;Publish</code> 去更新你的书的内容。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/publish.png" alt="image" /></p>

<h2>使用Git</h2>

<p>你可以使用git去发表和更新你的书</p>

<pre><code>$ git push https://push.gitbook.io//.git
</code></pre>

<p>它将会提示你的用户名(用户名或者邮件)和密码(密码或者api token)</p>

<h2>下一步</h2>

<p>一旦你把内容发布到GitBook.io,您需要检查您的构建的状态。</p>

<p><strong><a href="http://help.gitbook.io/book/build.html">了解更多</a></strong></p>

<h1>构建</h1>

<p>通过使用<strong>git</strong>或者<strong>编辑器</strong>发布内容后,GitBook.io将开始不同的构建:</p>

<ul>
<li><strong>website</strong>:它将生成的网站</li>
<li><strong>json</strong>:它将提取关于这本书的元数据(摘要、介绍…)</li>
<li><strong>epub</strong>:它将生成epub下载</li>
<li><strong>pdf</strong>:它将生成pdf下载</li>
</ul>


<h2>构建列表</h2>

<p>你书中<strong>活动选项卡</strong>让你遵循构建的演变</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/activity.png" alt="image" /></p>

<h2>构建细节</h2>

<p>当点击构建连接“logs”，你可以访问一个细节页面。本页面将会让你看到构建过程的输出。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/build.png" alt="image" /></p>

<h2>修正错误</h2>

<p>如果构建失败,您可以使用日志来调试这个问题和发布一个确定的内容。</p>

<p><strong><a href="http://help.gitbook.io/book/errors.html">了解更多关于常见错误</a></strong></p>

<h1>常见错误</h1>

<p>这是一个常见构建错误列表</p>

<hr />

<pre><code>Error loading plugins: plugin1, ...
</code></pre>

<p>这个错误是发生因为Gitbook不能解决一个插件(或插件是无效的)。外部插件需要被指定到node.js 依赖字段中package.json文件。了解更多关于package.json格式。</p>

<p>例如,如果你的书依赖于Autocover插件,您需要一个package.json文件包含以下内容:</p>

<pre><code>{
    "name": "mybook",
    "version": "0.0.0",
    "description": "",
    "repository": {
        "type": "git",
    "url": "https://github.com/Me/mybook.git"
      },
    "author": "Me &lt;me@gmail.com&gt;",
    "dependencies": {
    "gitbook-plugin-autocover": "0.0.5"
    }
}
</code></pre>

<h1>封面</h1>

<p>为了让你的书在GitBook.io更加优雅，你可以指定一个封面。</p>

<p>一个封面被指定是<strong>cover.jpg</strong>文件，一个<strong>cover_small.jpg</strong>也可以存在作为一个封面更小的版本。封面应该是一个<strong>JPEG</strong>文件。</p>

<h2>合适大小</h2>

<table class="table table-bordered table-striped table-condensed">
<tr>
<td></td>
<td>Big</td>
<td>Small</td>
</tr>
<tr>
<td>File</td>
<td>cover.jpg</td>
<td>cover_small.jpg</td>
</tr>
<tr>
<td>Size</td>
<td>1800x2360</td>
<td>200x262</td>
</tr>
</table>


<h2>自动封面</h2>

<p>GitBook插件(autocover)也可以用来生成一个封面文件,或者只是生成cover_small.jpg从你大的封面。</p>

<p><strong><a href="https://github.com/GitbookIO/plugin-autocover">了解更多的自动封面</a></strong></p>

<h2>指南</h2>

<p>一个好的封面遵守一下指南：</p>

<ul>
<li>没有边框</li>
<li>清晰可见的文本标题</li>
<li>在小版本上重要文本也可见</li>
</ul>


<h1>定制域名</h1>

<p>在<strong>Gitbook.io</strong>上所有的书可以通过<a href="http://.gitbooks.io/{book}/">http://.gitbooks.io/{book}/</a>.链接地址访问</p>

<p>不过你也能配置你的书使用一个自定制的域名（一个免费功能在GitBook.io）</p>

<p>添加一个自定制域名的书过程是很容易的。</p>

<ol>
<li>添加你的域名在你的书中设置.为了使用您自己的域名,你需要改变你的域名注册:</li>
<li>登录到你的域名注册和找允许您添加/编辑主机记录部分,经常发现在设置菜单“编辑DNS”,“主机记录”或“区域文件控制”。</li>
<li>设置www记录一个CNAME和URL字段设置为:www.gitbook.io。</li>
<li>把naked域(yourdomain.com)重定向到www.yourdomain.com,把这个选择指向这个域名。这通常被发现在“转发”,“URL转发”或“URL重定向”。</li>
</ol>


<p>可能需要几个小时为域名的变化。检查是否准备好或设置与GitBook定制域,输入您的域名(包括www)如下:</p>

<h1>可见性</h1>

<h2>公共/私人</h2>

<p>你的书可以<strong>公共</strong>或<strong>私人</strong>。公共图书对每个人都可见但只有collaborators 可以更新它。私人书籍只对collaborators可见。
　　
你可以把你的书从公共转换私人和从私人到公共。</p>

<h2>支付书</h2>

<p>书籍只能公共支付。</p>

<h2>Home /探索页面</h2>

<p>首页和探索页面包含书列表已经成功建造。我们建议设置封面图片。</p>

<h1>练习和测试</h1>

<h2>练习</h2>

<p>一本书可以包含互动练习(目前只在Javascript)。是一个代码的挑战提供给读者的练习,这是给定一个代码编辑器编写解决方案,检查对这本书作者的验证代码。</p>

<p>一个练习由4部分组成：</p>

<ul>
<li>练习<strong>留言</strong>/目标(在markdown/文本)</li>
<li><strong>初始代</strong>码显示给用户,提供一个起点</li>
<li><strong>解决方案</strong>的代码,是一个正确的解决方案</li>
<li><strong>验证</strong>代码,测试用户的输入的正确性</li>
</ul>


<p>练习需要开始和完成带有分隔标识(<code>——</code>或<code>* * *</code>)。它应该包含3代码元素(<strong>基地</strong>,<strong>解决方案</strong>和<strong>验证</strong>)。它可以包含第4元素来提供<strong>上下文</strong>代码(函数,导入库等…不应该显示给用户)。</p>

<pre><code>---

Define a variable `x` equal to 10.

```js
var x =
```

```js
var x = 10;
```

```js
assert(x == 10);
```

```js
// This is context code available everywhere
// The user will be able to call magicFunc in his codefunction magicFunc() {  
  return 3;
  }```

  ---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/new.png" alt="image" /></p>

<h2>测验</h2>

<p>一本书可以包含互动测验
在和练习的相同方式下测验也可以被定义</p>

<pre><code>---

Here is the introduction for the quiz

This is Question 1:
- [x] This is the proposition 1 (the correct one)
- [ ] This is the proposition 2

&gt; This is a help message when the answer to question 1 is wrong

This is Question 2:
- [ ] This is the proposition 1
- [x] This is the proposition 2 (correct)
- [x] This is the proposition 3 (correct)

&gt; This is a help message when the answer to question 2 is wrong

---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/result.png" alt="image" /></p>

<h1>谷歌Authorship</h1>

<p>使用Authorship能提高书籍的搜索结果。
　　
GitBook链接到谷歌作者必须先登录或创建一个Google +概要。
　　</p>

<ul>
<li>连接你的Google帐户<a href="https://www.gitbook.io/settings">设置</a>。</li>
<li>进入关于你G +的页面。</li>
<li>发现底部的“链接”章节。</li>
<li>在章节“链接”有三个选项。“其他配置文件”、“贡献者”,和“链接”。</li>
<li>点击“添加自定义链接”的“贡献者”一节&amp;命名为“GitBook”“标签”字段</li>
<li>Gitbook概要文件的URL添加到URL字段(<a href="https://www.gitbook.io/@twitter_username">https://www.gitbook.io/@twitter_username</a>)</li>
<li>点击保存并返回你的G +概要文件</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/29/swift/"/>
    <updated>2014-06-29T15:10:36+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/29/swift</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/29/swift.png" alt="image" /></p>

<!--more-->


<p>Swift一种编译式编程语言,由苹果公司推出,用来撰写OS X和iOS应用程序。2014年,在AppleWWDC所发布,设计Swift时,苹果公司有意让Swift与Objective-C共存在苹果公司的操作系统上。</p>

<h3>历史</h3>

<p>2010年7月,苹果开发者工具部门总监克里斯·拉特纳开始着手Swift编程语言的设计工作,以一年时间,完成基本架构后,他领导了一个设计团队大力参与其中。Swift大约历经4年的开发期,2014年6月发表。
苹果宣称Swift的特点是:快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译,可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果,能让Swift源代码在撰写过程中能实时显示出其运行结果。拉特纳本人强调,Playgrounds很大程度是受到布雷特·维克多（Bret Victor）理念的启发。</p>

<h3>特色</h3>

<p>Swift取消了Objective C的指针及其他不安全访问的使用,并舍弃Objective C早期套用Smalltalk之语法,全面改为句点表示法（dot-notation）。同许多script语言一样,Swift可以推断变量类型（var, variant）。同时,它提供了类似Java的命名空间(namespace)、泛型(generic)、运算对象重载（operator overloading）。Swift被简单的形容为 “没有C的Objective-C”（Objective-C without the C）。</p>

<h3>类型与变量</h3>

<p>在Cocoa与Cocoa Touch的环境下,许多共用的类物都放在Foundation Kit库下,这些类型包含了NSString字符串库 (使用 Unicode), 还有集合类型 NSArray 与 NSDictionary。Objective-C 提供了语法糖（syntactic sugar）的方式让这些对象可以集成在同一个语言里。例如NSString之间合并的表示法如下:</p>

<pre><code>NSString *str = @"hello,";
str = [str stringByAppendingString:@" world"];  
</code></pre>

<p>在Swift里, 字符串的累积可以用加法（+）运算对象作为第一级公民（First-class citizen）的方式直接完成, 上述的例子可以简化为</p>

<pre><code>var str = "hello,"; str += " world"
</code></pre>

<p>过去Cocoa（以及Cocoa Touch）的架构总是被分成两种版本，一种是可变的（mutable）,也就是可以在运行时期（runtime）改变；另一种是不可变的（immutable）,其初始值不可改变,例如NSArray与MSMutableArray就是数组的两种版本。在Swift语言的世界里仍延续这个传统,但更简化为使用 let 关键字去设置常数（constant variable）。至于可变的(Mutable)对象则使用var关键字。Swift语言使用类似C#或Javascript的var定义变量,但特性又不尽相同,Swift不会直接指派初始值给变量,亦即变量不会有默认值,所以使用var变量之前必须先初始化，不然会发生编译时期的错误。</p>

<p>为了方便使用,Swift还提供Optional的定义来声明nil-free references。声明Optional只需要在类型后面加上问号(?)即可。一旦var变量声明为Optional的，其初始值就会被默认为nil。Optional本质上是enum，有定义None和Some两种类型，nil即是Optional.None。</p>

<h3>库、运行时期与部署</h3>

<p>Swift在 Mac OS 和 iOS 平台可以和Object-C使用相同的运行时期(runtime)。这意味着Swift 程序可以运行于目前已存在的平台之上，包含 iOS 6 和 OS X 10.8 都可以运行Swift的程序。 更重要的, Swift 和 Obj-C 的代码可并存于单一程序内, 这种延伸就如同C 和 C++ 的关系一样。</p>

<p>为了争取大量的开发人员并重复使用已存在的代码, Xcode 6 允许在app target导入Objective-C文件供给Swift使用，通过Objective-C的桥接头文件（bridging header）来暴露给 Swift。当开发人员添加 Swift 文件到现有的Objective-C应用程序时，Xcode 会自动创建这些头文件。例如, 一个Swift 知名的类型 &ldquo;MyClass&rdquo; 可用于 Obj-C 的方式 #import &ldquo;MyClass-Swift.h&#8221;。</p>

<h3>存储器管理</h3>

<p>Swift全面使用自动引用计数(ARC)来管理存储器,取代过去Objective C的垃圾回收功能。过去在Objective-C中,强引用(strong reference)即为非ARC中的retain,而弱引用(weak reference)即为非ARC中的assign. 为了解决循环引用的问题,Swift提供unowned, 不能设定为optional types，不能加上问号(?)或惊叹号(!)。</p>

<h3>除错以及其他元素</h3>

<p>Xcode的除错机制针对Swift语言提供REPL（Read-Eval-Print Loop, 这是源自emacs的术语）环境,可以利用Swift语法来评估或与其他程序交互，使Swift编程具有类似Python与Ruby交互性接口（Interactive Shell）。</p>

<h3>类似Objective-C之处</h3>

<ul>
<li>基本数值类型（numeric types）大致相同 (例如Int, UInt, Float, Double)</li>
<li>大量的C 运算对象被移出Swift, 但又引入一些新运算对象。</li>
<li>大括号被用于组群陈述（group statements）。</li>
<li>变量之赋值使用等于符号, 但比较则使用“连续两个等于”(==)运算对象。还有一个新的运算对象，“连续三个等于”(===)被用来判断常数或变量之间是否为同一对象之实例(instance)。</li>
<li>中括号([], Square brackets)用于数组的表示, 声明阵例之后, 可以指派索引值(index)来进行元素(element)之访问。</li>
<li>控制陈述（control statement）, for, while, if, switch 与Ojbective-C都十分类似, 但有延伸功能, 像是 for in 用于集合(collection)的轮询, switch 还可以接受非整数的cases条件值, 诸如此类。</li>
</ul>


<h3>不同于Objective-C之处</h3>

<ul>
<li>陈述句（statement）不须再使用分号 (&lsquo;;&rsquo;)做为退出, 但分号还是可以在一行以内作为两个以上陈述的分隔。</li>
<li>头文件(Header files)不再需要。</li>
<li>注解方式 /<em> &hellip; </em>/ 可以为嵌套（nested）注解, 意思是指注解内可以再有注解, 过去有些C或C++编译器不支持嵌套注解。</li>
<li>强类型(strong type)</li>
<li>类型推论或隐含类型(Type inference)</li>
<li>支持泛型编程。</li>
<li>函数为第一等类型(first-class object)，这意味着函数可以作为其他函数的参数与返回值。</li>
<li>运算对象可在类型内重新定义 (运算对象重载)。可以生成新的运算对象。</li>
<li>字符串全方面支持 Unicode。某些字符甚至可以成为语言的名称。</li>
<li>许多C语言家族过去恶名昭彰的怪语法（error-prone behaviors）也被改变:

<ul>
<li>不再存在指针。</li>
<li>指派(Assignments)不再回传值。正确写法是 if (i==0) ，一般容易误写成 if (i=0) 会造成编译时期错误(compile-time error)。</li>
<li>在switch 的区块内不需要再使用 break 叙述句。另外, case后面都需要有可执行的代码（C或C++可连续使用多个case而不需要额外的代码）, 否则会发生编译错误。</li>
<li>变量和常数都要被初始化，而且数组(array)的界限也要确认清楚。</li>
<li>溢出（overflows）的问题。C语言没有强制整数类型（signed integers）的界限, 常常在运行时间发生问题。Swift可以通过整数类型的max或min属性取得最大值或最小值。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>

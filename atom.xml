<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mae Blog]]></title>
  <link href="http://zhouhongmeiblog.github.io/atom.xml" rel="self"/>
  <link href="http://zhouhongmeiblog.github.io/"/>
  <updated>2014-06-30T22:24:39+08:00</updated>
  <id>http://zhouhongmeiblog.github.io/</id>
  <author>
    <name><![CDATA[maebook]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GitBook]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook/"/>
    <updated>2014-06-30T15:10:45+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/30/gitbook</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/gitbook.png" alt="image" /></p>

<!--more-->


<h1>序言</h1>

<h2>文档</h2>

<p>这本书包含GitBook和GitBook.io整个文档。在GitHub允许你改进这个文档。</p>

<p>GitBook是一个工具来构建好的书同时也克使用Git和markdown。你的书可以生成多种格式:</p>

<ul>
<li><strong>Static Website</strong> :这是默认格式,它生成一个完整的交互式静态网站</li>
<li><strong>PDF</strong> :一个完整的PDF和书后的练习解答</li>
<li><strong>eBook</strong> :一个完整的PDF和书后的练习解答</li>
</ul>


<p>GitBook是开放源代码的,完全免费,工具的源代码可以在GitHub上。</p>

<h2>需要帮助</h2>

<p>我们总是乐意帮忙你的书或其他任何你可能有问题。你可以问一个问题或发表在GitHub问题上一个问题或通过电子邮件与我们联系:contact@gitbook.io。</p>

<h1>编辑器</h1>

<h2>桌面编辑器</h2>

<p>一个用于桌面编辑器。它是开放源代码的,可以在GitHub的源代码。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h2>下载</h2>

<p>这些平台的编辑器可以下载：</p>

<ul>
<li>Windows</li>
<li>Mac OS</li>
<li>Linux 32bits</li>
<li>Linux 64bits</li>
</ul>


<h2>关联你的GitBook.io账户</h2>

<p>你可以容易连接GitBook.io账户通过在身份对话框中输入您的用户名和密码的身份验证对话框:</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/editor.png" alt="image" /></p>

<h1>格式</h1>

<p>GitBook的使用规范是在基于markdown文件。
一本书是一个Git存储库包含至少2文件:README.md和SUMMARY.md</p>

<h3>README.md</h3>

<p>通常情况下,这应该是你的书的介绍。它自动会被添加到最后的总结中。</p>

<h3>SUMMARY.md</h3>

<p>这个SUMMARY.md定义你的书结构。它应该包含一个章节列表,链接到各自的页面。</p>

<p>例子：</p>

<pre><code>* [English](en/)
* [French](fr/)
* [Español](es/)
</code></pre>

<p>文件不包含在SUMMARY.md中将不会被gitbook处理。</p>

<h2>多语言</h2>

<p>GitBook支持用多种语言编写的书籍。在标准GitBook格式下，每种语言应该是子目录和一个文件命名为LANGS.md应该出现在库的根目录中使用以下格式:</p>

<pre><code># Summary
This is the summary of my book.
* [section 1](section1/README.md)    
    * [example 1](section1/example1.md)    
    * [example 2](section1/example2.md)
* [section 2](section2/README.md)    
    * [example 1](section2/example1.md)
</code></pre>

<p>你可以看到一个完整的示例通过 Learn Git书。</p>

<h2>忽略文件和文件夹</h2>

<p>GitBook 将阅读.gitignore .bookignore和.ignore 文件，跳过文件和文件夹的列表。(这些文件的格式,和.gitignore一样遵循相同的规范)</p>

<h1>发表内容</h1>

<p> 当你的书是gitbook.io创建的,你需要发表一些内容。</p>

<h2>使用编辑器</h2>

<p>如果你还没有编辑器,<a href="http://help.gitbook.io/editor/README.html">免费安装</a>。</p>

<p>连接你的GitBook.io账户编辑器。您可以使用菜单<code>Book &gt;Publish</code> 去更新你的书的内容。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/publish.png" alt="image" /></p>

<h2>使用Git</h2>

<p>你可以使用git去发表和更新你的书</p>

<pre><code>$ git push https://push.gitbook.io//.git
</code></pre>

<p>它将会提示你的用户名(用户名或者邮件)和密码(密码或者api token)</p>

<h2>下一步</h2>

<p>一旦你把内容发布到GitBook.io,您需要检查您的构建的状态。</p>

<p><strong><a href="http://help.gitbook.io/book/build.html">了解更多</a></strong></p>

<h1>构建</h1>

<p>通过使用<strong>git</strong>或者<strong>编辑器</strong>发布内容后,GitBook.io将开始不同的构建:</p>

<ul>
<li><strong>website</strong>:它将生成的网站</li>
<li><strong>json</strong>:它将提取关于这本书的元数据(摘要、介绍…)</li>
<li><strong>epub</strong>:它将生成epub下载</li>
<li><strong>pdf</strong>:它将生成pdf下载</li>
</ul>


<h2>构建列表</h2>

<p>你书中<strong>活动选项卡</strong>让你遵循构建的演变</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/activity.png" alt="image" /></p>

<h2>构建细节</h2>

<p>当点击构建连接“logs”，你可以访问一个细节页面。本页面将会让你看到构建过程的输出。</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/build.png" alt="image" /></p>

<h2>修正错误</h2>

<p>如果构建失败,您可以使用日志来调试这个问题和发布一个确定的内容。</p>

<p><strong><a href="http://help.gitbook.io/book/errors.html">了解更多关于常见错误</a></strong></p>

<h1>常见错误</h1>

<p>这是一个常见构建错误列表</p>

<hr />

<pre><code>Error loading plugins: plugin1, ...
</code></pre>

<p>这个错误是发生因为Gitbook不能解决一个插件(或插件是无效的)。外部插件需要被指定到node.js 依赖字段中package.json文件。了解更多关于package.json格式。</p>

<p>例如,如果你的书依赖于Autocover插件,您需要一个package.json文件包含以下内容:</p>

<pre><code>{
    "name": "mybook",
    "version": "0.0.0",
    "description": "",
    "repository": {
        "type": "git",
    "url": "https://github.com/Me/mybook.git"
      },
    "author": "Me &lt;me@gmail.com&gt;",
    "dependencies": {
    "gitbook-plugin-autocover": "0.0.5"
    }
}
</code></pre>

<h1>封面</h1>

<p>为了让你的书在GitBook.io更加优雅，你可以指定一个封面。</p>

<p>一个封面被指定是<strong>cover.jpg</strong>文件，一个<strong>cover_small.jpg</strong>也可以存在作为一个封面更小的版本。封面应该是一个<strong>JPEG</strong>文件。</p>

<h2>合适大小</h2>

<table class="table table-bordered table-striped table-condensed">
<tr>
<td></td>
<td>Big</td>
<td>Small</td>
</tr>
<tr>
<td>File</td>
<td>cover.jpg</td>
<td>cover_small.jpg</td>
</tr>
<tr>
<td>Size</td>
<td>1800x2360</td>
<td>200x262</td>
</tr>
</table>


<h2>自动封面</h2>

<p>GitBook插件(autocover)也可以用来生成一个封面文件,或者只是生成cover_small.jpg从你大的封面。</p>

<p><strong><a href="https://github.com/GitbookIO/plugin-autocover">了解更多的自动封面</a></strong></p>

<h2>指南</h2>

<p>一个好的封面遵守一下指南：</p>

<ul>
<li>没有边框</li>
<li>清晰可见的文本标题</li>
<li>在小版本上重要文本也可见</li>
</ul>


<h1>定制域名</h1>

<p>在<strong>Gitbook.io</strong>上所有的书可以通过<a href="http://.gitbooks.io/{book}/">http://.gitbooks.io/{book}/</a>.链接地址访问</p>

<p>不过你也能配置你的书使用一个自定制的域名（一个免费功能在GitBook.io）</p>

<p>添加一个自定制域名的书过程是很容易的。</p>

<ol>
<li>添加你的域名在你的书中设置.为了使用您自己的域名,你需要改变你的域名注册:</li>
<li>登录到你的域名注册和找允许您添加/编辑主机记录部分,经常发现在设置菜单“编辑DNS”,“主机记录”或“区域文件控制”。</li>
<li>设置www记录一个CNAME和URL字段设置为:www.gitbook.io。</li>
<li>把naked域(yourdomain.com)重定向到www.yourdomain.com,把这个选择指向这个域名。这通常被发现在“转发”,“URL转发”或“URL重定向”。</li>
</ol>


<p>可能需要几个小时为域名的变化。检查是否准备好或设置与GitBook定制域,输入您的域名(包括www)如下:</p>

<h1>可见性</h1>

<h2>公共/私人</h2>

<p>你的书可以<strong>公共</strong>或<strong>私人</strong>。公共图书对每个人都可见但只有collaborators 可以更新它。私人书籍只对collaborators可见。
　　
你可以把你的书从公共转换私人和从私人到公共。</p>

<h2>支付书</h2>

<p>书籍只能公共支付。</p>

<h2>Home /探索页面</h2>

<p>首页和探索页面包含书列表已经成功建造。我们建议设置封面图片。</p>

<h1>练习和测试</h1>

<h2>练习</h2>

<p>一本书可以包含互动练习(目前只在Javascript)。是一个代码的挑战提供给读者的练习,这是给定一个代码编辑器编写解决方案,检查对这本书作者的验证代码。</p>

<p>一个练习由4部分组成：</p>

<ul>
<li>练习<strong>留言</strong>/目标(在markdown/文本)</li>
<li><strong>初始代</strong>码显示给用户,提供一个起点</li>
<li><strong>解决方案</strong>的代码,是一个正确的解决方案</li>
<li><strong>验证</strong>代码,测试用户的输入的正确性</li>
</ul>


<p>练习需要开始和完成带有分隔标识(<code>——</code>或<code>* * *</code>)。它应该包含3代码元素(<strong>基地</strong>,<strong>解决方案</strong>和<strong>验证</strong>)。它可以包含第4元素来提供<strong>上下文</strong>代码(函数,导入库等…不应该显示给用户)。</p>

<pre><code>---

Define a variable `x` equal to 10.

```js
var x =
```

```js
var x = 10;
```

```js
assert(x == 10);
```

```js
// This is context code available everywhere
// The user will be able to call magicFunc in his codefunction magicFunc() {  
  return 3;
  }```

  ---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/new.png" alt="image" /></p>

<h2>测验</h2>

<p>一本书可以包含互动测验
在和练习的相同方式下测验也可以被定义</p>

<pre><code>---

Here is the introduction for the quiz

This is Question 1:
- [x] This is the proposition 1 (the correct one)
- [ ] This is the proposition 2

&gt; This is a help message when the answer to question 1 is wrong

This is Question 2:
- [ ] This is the proposition 1
- [x] This is the proposition 2 (correct)
- [x] This is the proposition 3 (correct)

&gt; This is a help message when the answer to question 2 is wrong

---
</code></pre>

<p>它将显示如下：</p>

<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/30/result.png" alt="image" /></p>

<h1>谷歌Authorship</h1>

<p>使用Authorship能提高书籍的搜索结果。
　　
GitBook链接到谷歌作者必须先登录或创建一个Google +概要。
　　</p>

<ul>
<li>连接你的Google帐户<a href="https://www.gitbook.io/settings">设置</a>。</li>
<li>进入关于你G +的页面。</li>
<li>发现底部的“链接”章节。</li>
<li>在章节“链接”有三个选项。“其他配置文件”、“贡献者”,和“链接”。</li>
<li>点击“添加自定义链接”的“贡献者”一节&amp;命名为“GitBook”“标签”字段</li>
<li>Gitbook概要文件的URL添加到URL字段(<a href="https://www.gitbook.io/@twitter_username">https://www.gitbook.io/@twitter_username</a>)</li>
<li>点击保存并返回你的G +概要文件</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://zhouhongmeiblog.github.io/blog/2014/06/29/swift/"/>
    <updated>2014-06-29T15:10:36+08:00</updated>
    <id>http://zhouhongmeiblog.github.io/blog/2014/06/29/swift</id>
    <content type="html"><![CDATA[<p><img src="http://zhouhongmeiblog.github.io/images/2014/06/29/swift.png" alt="image" /></p>

<!--more-->


<p>Swift一种编译式编程语言,由苹果公司推出,用来撰写OS X和iOS应用程序。2014年,在AppleWWDC所发布,设计Swift时,苹果公司有意让Swift与Objective-C共存在苹果公司的操作系统上。</p>

<h3>历史</h3>

<p>2010年7月,苹果开发者工具部门总监克里斯·拉特纳开始着手Swift编程语言的设计工作,以一年时间,完成基本架构后,他领导了一个设计团队大力参与其中。Swift大约历经4年的开发期,2014年6月发表。
苹果宣称Swift的特点是:快速、现代、安全、互动，而且明显优于Objective-C语言。Swift以LLVM编译,可以使用现有的Cocoa和Cocoa Touch框架。Xcode Playgrounds功能是Swift为苹果开发工具带来的最大创新，该功能提供强大的互动效果,能让Swift源代码在撰写过程中能实时显示出其运行结果。拉特纳本人强调,Playgrounds很大程度是受到布雷特·维克多（Bret Victor）理念的启发。</p>

<h3>特色</h3>

<p>Swift取消了Objective C的指针及其他不安全访问的使用,并舍弃Objective C早期套用Smalltalk之语法,全面改为句点表示法（dot-notation）。同许多script语言一样,Swift可以推断变量类型（var, variant）。同时,它提供了类似Java的命名空间(namespace)、泛型(generic)、运算对象重载（operator overloading）。Swift被简单的形容为 “没有C的Objective-C”（Objective-C without the C）。</p>

<h3>类型与变量</h3>

<p>在Cocoa与Cocoa Touch的环境下,许多共用的类物都放在Foundation Kit库下,这些类型包含了NSString字符串库 (使用 Unicode), 还有集合类型 NSArray 与 NSDictionary。Objective-C 提供了语法糖（syntactic sugar）的方式让这些对象可以集成在同一个语言里。例如NSString之间合并的表示法如下:</p>

<pre><code>NSString *str = @"hello,";
str = [str stringByAppendingString:@" world"];  
</code></pre>

<p>在Swift里, 字符串的累积可以用加法（+）运算对象作为第一级公民（First-class citizen）的方式直接完成, 上述的例子可以简化为</p>

<pre><code>var str = "hello,"; str += " world"
</code></pre>

<p>过去Cocoa（以及Cocoa Touch）的架构总是被分成两种版本，一种是可变的（mutable）,也就是可以在运行时期（runtime）改变；另一种是不可变的（immutable）,其初始值不可改变,例如NSArray与MSMutableArray就是数组的两种版本。在Swift语言的世界里仍延续这个传统,但更简化为使用 let 关键字去设置常数（constant variable）。至于可变的(Mutable)对象则使用var关键字。Swift语言使用类似C#或Javascript的var定义变量,但特性又不尽相同,Swift不会直接指派初始值给变量,亦即变量不会有默认值,所以使用var变量之前必须先初始化，不然会发生编译时期的错误。</p>

<p>为了方便使用,Swift还提供Optional的定义来声明nil-free references。声明Optional只需要在类型后面加上问号(?)即可。一旦var变量声明为Optional的，其初始值就会被默认为nil。Optional本质上是enum，有定义None和Some两种类型，nil即是Optional.None。</p>

<h3>库、运行时期与部署</h3>

<p>Swift在 Mac OS 和 iOS 平台可以和Object-C使用相同的运行时期(runtime)。这意味着Swift 程序可以运行于目前已存在的平台之上，包含 iOS 6 和 OS X 10.8 都可以运行Swift的程序。 更重要的, Swift 和 Obj-C 的代码可并存于单一程序内, 这种延伸就如同C 和 C++ 的关系一样。</p>

<p>为了争取大量的开发人员并重复使用已存在的代码, Xcode 6 允许在app target导入Objective-C文件供给Swift使用，通过Objective-C的桥接头文件（bridging header）来暴露给 Swift。当开发人员添加 Swift 文件到现有的Objective-C应用程序时，Xcode 会自动创建这些头文件。例如, 一个Swift 知名的类型 &ldquo;MyClass&rdquo; 可用于 Obj-C 的方式 #import &ldquo;MyClass-Swift.h&#8221;。</p>

<h3>存储器管理</h3>

<p>Swift全面使用自动引用计数(ARC)来管理存储器,取代过去Objective C的垃圾回收功能。过去在Objective-C中,强引用(strong reference)即为非ARC中的retain,而弱引用(weak reference)即为非ARC中的assign. 为了解决循环引用的问题,Swift提供unowned, 不能设定为optional types，不能加上问号(?)或惊叹号(!)。</p>

<h3>除错以及其他元素</h3>

<p>Xcode的除错机制针对Swift语言提供REPL（Read-Eval-Print Loop, 这是源自emacs的术语）环境,可以利用Swift语法来评估或与其他程序交互，使Swift编程具有类似Python与Ruby交互性接口（Interactive Shell）。</p>

<h3>类似Objective-C之处</h3>

<ul>
<li>基本数值类型（numeric types）大致相同 (例如Int, UInt, Float, Double)</li>
<li>大量的C 运算对象被移出Swift, 但又引入一些新运算对象。</li>
<li>大括号被用于组群陈述（group statements）。</li>
<li>变量之赋值使用等于符号, 但比较则使用“连续两个等于”(==)运算对象。还有一个新的运算对象，“连续三个等于”(===)被用来判断常数或变量之间是否为同一对象之实例(instance)。</li>
<li>中括号([], Square brackets)用于数组的表示, 声明阵例之后, 可以指派索引值(index)来进行元素(element)之访问。</li>
<li>控制陈述（control statement）, for, while, if, switch 与Ojbective-C都十分类似, 但有延伸功能, 像是 for in 用于集合(collection)的轮询, switch 还可以接受非整数的cases条件值, 诸如此类。</li>
</ul>


<h3>不同于Objective-C之处</h3>

<ul>
<li>陈述句（statement）不须再使用分号 (&lsquo;;&rsquo;)做为退出, 但分号还是可以在一行以内作为两个以上陈述的分隔。</li>
<li>头文件(Header files)不再需要。</li>
<li>注解方式 /<em> &hellip; </em>/ 可以为嵌套（nested）注解, 意思是指注解内可以再有注解, 过去有些C或C++编译器不支持嵌套注解。</li>
<li>强类型(strong type)</li>
<li>类型推论或隐含类型(Type inference)</li>
<li>支持泛型编程。</li>
<li>函数为第一等类型(first-class object)，这意味着函数可以作为其他函数的参数与返回值。</li>
<li>运算对象可在类型内重新定义 (运算对象重载)。可以生成新的运算对象。</li>
<li>字符串全方面支持 Unicode。某些字符甚至可以成为语言的名称。</li>
<li>许多C语言家族过去恶名昭彰的怪语法（error-prone behaviors）也被改变:

<ul>
<li>不再存在指针。</li>
<li>指派(Assignments)不再回传值。正确写法是 if (i==0) ，一般容易误写成 if (i=0) 会造成编译时期错误(compile-time error)。</li>
<li>在switch 的区块内不需要再使用 break 叙述句。另外, case后面都需要有可执行的代码（C或C++可连续使用多个case而不需要额外的代码）, 否则会发生编译错误。</li>
<li>变量和常数都要被初始化，而且数组(array)的界限也要确认清楚。</li>
<li>溢出（overflows）的问题。C语言没有强制整数类型（signed integers）的界限, 常常在运行时间发生问题。Swift可以通过整数类型的max或min属性取得最大值或最小值。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
